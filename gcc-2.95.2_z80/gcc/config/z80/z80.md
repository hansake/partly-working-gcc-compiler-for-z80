;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; Note:
;; This work is carried out as a paart of my learning. The port needs to be 
;; improved in many aspects.(The port is not complete yet).
 


;;- Instruction patterns.  When multiple patterns apply,
;;- the first one in the file is chosen.
;;-
;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
;;-
;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
;;- updates for most instructions. (This needs to be improved).

;;
;; The following constraints are used:
;;
;; Single pair registers:
;; a    register 'a'			 8-bit
;; b    register 'bc'			 16-bit
;; d    register 'de'			16-bit
;; w    register 'sp'			16-bit 
;; x    register 'x'			16-bit
;; y    register 'y'			16-bit
;; D    register 'hl+de'			32-bit 
;; u    register 'bc+iy'			32-bit 
;;
;; Group of registers:
;; q    register 'a' or 'b' ,'c','d' , 'e', 'ixh, 'ixl' , 'iyh', 'iyl'	 8-bit
;; A    register 'x', 'y'               16-bit
;; z	register 'hl', 'ix', 'iy'	16-bit
;;
;;
;; Immediate integer operand constraints:
;;   `L' is for range -65536 to 65536
;;   `M' is for values whose 16-bit low part is 0
;;   'N' is for +1 or -1.
;;
;; In many cases, it's not possible to use the 'g' or 'r' constraints.
;;


;;QImode values are not allowed in ix and iy registers. We might 
;; have to allow (I guess). May be when I compile some big code, I might be
;; knowing about this.

;; 32-bit Patterns:
;;     The z80 does not support 32-bit operations. Most of the
;;     32-bit patterns are defined to split the instruction in
;;     16-bits patterns. Providing split patterns generates better code
;;     than letting GCC implement the 3264-bit operation itself.
;;
;;
;; In test and compare patterns we save the operands and use them in the branch 
;; patterns, which actually emits a compare and branch instructions.
;; We really do not use test define_insn  patterns because for testing
;; an operand we need a compare instuction (sbc), which needs both the 
;; operands to be in registers. 
;;We generate compare patterns with the saved 
;;operands in the following branch patterns

(define_expand "tstsi"
  [(set (cc0)
	(match_operand:SI 0 "tst_operand" ""))]
  ""
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = const0_rtx;
  DONE;
}")

(define_expand "tsthi"
  [(set (cc0)
	(match_operand:HI 0 "tst_operand" ""))]
  ""
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = const0_rtx;
  DONE;
}")

(define_insn "tsthi_1"
  [(set (cc0)
        (match_operand:HI 0 "tst_operand" "h"))]
  "0"
  "sbc\\t%0,0")

(define_expand "tstqi"
  [(set (cc0)
	(match_operand:QI 0 "tst_operand" ""))]
  ""
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = const0_rtx;
  DONE;
}")

;;--------------------------------------------------------------------
;;- Compare
;;--------------------------------------------------------------------

(define_expand "cmpsi"
  [(set (cc0)
	(compare (match_operand:SI 0 "tst_operand" "")
		 (match_operand:SI 1 "cmp_operand" "")))]
  ""
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = operands[1];
  DONE;
}")

(define_expand "cmphi"
  [(set (cc0)
	(compare (match_operand:HI 0 "tst_operand" "")
		 (match_operand:HI 1 "cmp_operand" "")))]
  ""
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = operands[1];
  DONE;
}")

(define_insn "cmphi_1"
  [(set (cc0)
        (compare (match_operand:HI 0 "tst_operand" "h")
                 (match_operand:HI 1 "cmp_operand" "hbd")))]
  ""
"*
{
	operands[2] = gen_rtx_REG (QImode, HARD_A_REGNUM);   
	output_asm_insn (\"or\\t%2,%2\", operands);
    return\"sbc\\t%0,%1\";
}")


(define_expand "cmpqi"
  [(set (cc0)
	(compare (match_operand:QI 0 "tst_operand" "")
		 (match_operand:QI 1 "cmp_operand" "")))]
  ""
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = operands[1];
  DONE;
}")


(define_insn "cmpqi_1"
  [(set (cc0)
        (compare (match_operand:QI 0 "tst_operand" "a")
                 (match_operand:QI 1 "cmp_operand" "r")))]
  ""
  "*
{
   return \"cp\\t%0,%1\";
}")



(define_expand "cmpdf"
  [(set (cc0)
	(compare (match_operand:DF 0 "general_operand" "")
		 (match_operand:DF 1 "general_operand" "")))]
  "0"
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = operands[1];
  DONE;
}")

(define_expand "cmpsf"
  [(set (cc0)
	(compare (match_operand:SF 0 "general_operand" "")
		 (match_operand:SF 1 "general_operand" "")))]
  "0"
  "
{
  z80_compare_op0 = operands[0];
  z80_compare_op1 = operands[1];
  DONE;
}")



;;--------------------------------------------------------------------
;;-  Jumps and transfers
;;--------------------------------------------------------------------

;; We use the operands saved in test/compare patterns and emit the code
;;for compares and branches.
;;;;;;;; On Z80 we do n't have instructions for branching when the branch code
;;is GT, GTU, LE and LEU. So, when any of these codes are encountered we
;; swap the opernds followed by the comparision code.
;;The expands call a z80_expand_compare function from z80.c file with the
;;operands, comparision code and with argument 1. This is to indicate
;; you want to emit the code  (default).
;; Reason for the last argument: We need to emit two compares and a branch
;; for long value compares and branches. To distinguish between the scenarios.
;; should look for a better approach.

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (EQ, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (NE, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (GT, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (GTU, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (LT, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (LTU, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
z80_expand_compare_and_branch (GE, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (GEU, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "ble"
  [(set (pc)
	(if_then_else (le (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (LE, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "
{
 z80_expand_compare_and_branch (LEU, z80_compare_op0,
				     z80_compare_op1, operands[0],1);
  DONE;
}")

(define_insn "*beq"
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "jr\\tz,%l0")

(define_insn "*bne"
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
""
"jr\\tnz,%l0")

/* actually there is no instruction to test for the gt,le
													gtu and leu 
 So, we are canonicalizing the instructions for gt to lt
												le to ge
												gtu to ltu
												leu to geu
		by sawpping the operands.					*/

;;need to call a function setflag to  clear/set the sign flag based on the
;;overflow. (needs to go in libgcc1.). If the p/v bit of flags register is set
;;means I need to  
;; This should happen when you are jumping based on the sign flag, i.e m or p
;; in jp instruction.



(define_insn "*bgt"
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
 return \"jp\\tp,%l0\";
}")

(define_insn "*bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
""
"*
{
 return \"jr\\tnc,%l0\";
}")

(define_insn "*blt"
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "jp\\tm,%l0")


(define_insn "*bltu"
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
""
"jr\\tc,%l0")

(define_insn "*bge"
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "jp\\tp,%l0")

(define_insn "*bgeu"
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
""
"jr\\tnc,%l0")

;; no actual branch for the two.
 

(define_insn "*ble"
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
{
return\"jp\\tm,%l0\";
}")

(define_insn "*bleu"
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
""
"*
{
 return \"jr\\tc,%l0\";
}")
  
;;--------------------------------------------------------------------
;;- Negative test and branch
;;--------------------------------------------------------------------

;;negative braches. We nee to look more closely for the ones which we 
;;do n't have the instructions.guess!!! we need to jump on reverse conditions.
;;check the output template.


(define_insn ""
  [(set (pc)
	(if_then_else (eq (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
""
"jr\\tnz,%l0")

(define_insn ""
  [(set (pc)
	(if_then_else (ne (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
""
"jr\\tz,%l0")

;;no branch insn for le. 
 
(define_insn ""
  [(set (pc)
	(if_then_else (gt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "jp\\tm,%l0")

(define_insn ""
  [(set (pc)
	(if_then_else (gtu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
"jr\\tc,%l0")


(define_insn ""
  [(set (pc)
	(if_then_else (lt (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
""
"jp\\tp,%l0")

(define_insn ""
  [(set (pc)
	(if_then_else (ltu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
""
"jr\\tnc,%l0")

(define_insn ""
  [(set (pc)
	(if_then_else (ge (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
""
"jp\\tm,%l0")

(define_insn ""
  [(set (pc)
	(if_then_else (geu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
""
"jr\\t%c,%l0")

; no instruction for branchining on gt. 
  
(define_insn ""
  [(set (pc)
	(if_then_else (le (cc0)
			  (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
 "jp\\tp,%l0")

(define_insn ""
  [(set (pc)
	(if_then_else (leu (cc0)
			   (const_int 0))
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
"jr\\tnc,%l0")

;;--------------------------------------------------------------------
;;-  Move strict_low_part
;;--------------------------------------------------------------------
;;
;; The (strict_low_part ...) patterns are replaced by normal (set) patterns.
;; The replacement must be made at the very end because we loose the
;; (strict_low_part ...) information.  This is correct for our machine
;; description but not for GCC optimization passes.
;;

;;-----------------------
(define_insn "movstrictsi"
  [(set (strict_low_part (match_operand:SI 0 "non_push_operand" "=Dm"))
	(match_operand:SI 1 "general_operand" "Dim"))]
""  
"#")


;;-----------------------
(define_split
  [(set (strict_low_part (match_operand:SI 0 "non_push_operand" "=Dm"))
	(match_operand:SI 1 "general_operand" "Dim"))]
  "reload_completed"
  [(set (match_dup 0) (match_dup 1))]
  "")



(define_insn "movstricthi"
  [(set (strict_low_part (match_operand:HI 0 "non_push_operand" "=rm"))
	(match_operand:HI 1 "general_operand" "rmi"))]
  ""    
  "#")

(define_split
  [(set (strict_low_part (match_operand:HI 0 "non_push_operand" "=rm"))
	(match_operand:HI 1 "general_operand" "rim"))]
  "reload_completed"
  [(set (match_dup 0) (match_dup 1))]
  "")


;;-----------------------
(define_insn "movstrictqi"
  [(set (strict_low_part (match_operand:QI 0 "non_push_operand" "=rm"))
	(match_operand:QI 1 "general_operand" "rim"))]
  ""
  "#")


;;-----------------------
(define_split
  [(set (strict_low_part (match_operand:QI 0 "non_push_operand" "=rm"))
	(match_operand:QI 1 "general_operand" "rim"))]
  "reload_completed"
  [(set (match_dup 0) (match_dup 1))]
  "")


;;--------------------------------------------------------------------
;;- 32-bit Move Operations.
;; The movsi and movsf patterns are identical except for the mode.
;; When we move to/from a hard register (hl+de/bc+iy), we don't need a scratch.
;; Otherwise, a scratch register is used as intermediate register for
;; the move.  The '&' constraint is necessary to make sure the reload
;; pass does not give us a register that dies in the insn and is used
;; for input/output operands.
;;--------------------------------------------------------------------
(define_insn "movsi"
  [(set (match_operand:SI 0 "nonimmediate_operand" "=Du,r,m,m")
	(match_operand:SI 1 "general_operand"      "Du,mi,r,mi"))
   (clobber (match_scratch:HI 2                    "=X,X,X,&b"))]
  ""
  "#")

(define_split
  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,m,r,m")
	(match_operand:SI 1 "general_operand" "r,r,mi,mi"))
   (clobber (match_scratch:HI 2 "=X,X,X,&b"))]
  "reload_completed"
  [(const_int 0)]
  "z80_split_move (operands[0], operands[1], operands[2]);
   DONE;")

(define_insn "movsf"
  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,m,?r,m")
	(match_operand:SF 1 "general_operand" "r,r,mi,mi"))
   (clobber (match_scratch:HI 2 "=X,X,X,&b"))]
  ""
  "#")

(define_split
  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,m,?r,m")
	(match_operand:SF 1 "general_operand" "r,r,mi,mi"))
   (clobber (match_scratch:HI 2 "=X,X,X,&b"))]
  "reload_completed"
  [(const_int 0)]
  "z80_split_move (operands[0], operands[1], operands[2]);
   DONE;")


;-----------------------

(define_insn "*movhi2_push"
  [(set (match_operand:HI 0 "push_operand" "=<")
	(match_operand:HI 1 "register_operand" "hbdx*y"))]
  ""
"push\\t%1")


(define_insn "*movhi2_pop"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=hbdx*y")
	(match_operand:HI 1 "pop_operand" ">"))]
  ""
"pop\\t%0")

(define_expand "movhi"
  [(set (match_operand:HI 0 "nonimmediate_operand" "")
        (match_operand:HI 1 "general_operand" ""))]
  ""
  "
{
      if (GET_CODE (operands[0]) == MEM &&
          (GET_CODE (operands[1]) == MEM
           || GET_CODE (operands[1]) == CONST_INT))
        {
          operands[1] = force_reg (HImode, operands[1]);
        }
      else if (IS_STACK_PUSH (operands[0])
                && GET_CODE (operands[1]) != REG)
        {
			operands[1] = force_reg (HImode, operands[1]);   
		}
}")


(define_insn ""
[(set (match_operand:HI 0 "register_operand" "=h!xy")
	   (match_operand:HI 1 "stack_register_operand" "w"))]
""
"*
{
output_asm_insn (\"ld\\t%0,0\", operands);
return \"add\\t%0,%1\";

}")
;; U is indexed memory and R is symbolic memory (Symbolic variables)
;; In HImode we do n't have ld sp, (ix+d) and ld (ix+d),sp we might have to
;; support this.

(define_insn "*movhi"
 [(set (match_operand:HI 0 "nonimmediate_operand" "=r,!w,hbd!x*y,m,!w,R,r")
	(match_operand:HI 1 "general_operand" "0,h!xyi,m,hbd!x*y,R,!w,ri"))]
""
"*
{

if (which_alternative == 0)
	return \"nop\";

 if (which_alternative ==1)
  return \"ld\\t%0,%1\";  
 if (which_alternative ==2)
  return \"ld\\t%0,(%1)\";
 if (which_alternative == 3)  
   return \"ld\\t(%0),%1\";
 if (which_alternative ==4)
  return \"ld\\t%0,(%1)\";
 if (which_alternative ==5)
  return \"ld\\t(%0),%1\";
if (which_alternative == 6){
	if (GET_CODE (operands[1]) == REG)
	{
		output_asm_insn (\"push\\t%1\", operands);
		return \"pop\\t%0\";
	}
	else
     return \"ld\\t%0,%1\";  
}
}")
;;--------------------------------------------------------------------
;;- 8-bit Move Operations.
;; We need a scratch register when moving to/from symbolic memory.
;;--------------------------------------------------------------------
;;
;;-----------------------

(define_expand "movqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "")
	(match_operand:QI 1 "general_operand" ""))]
  ""
  "
{
	if (GET_CODE (operands[0]) == MEM  &&  
			 GET_CODE (operands[1]) == CONST_INT)
	{
		if(symbolic_memory_operand(operands[0], QImode))   
			operands[1] = force_reg (QImode, operands[1]);
	}

	if (GET_CODE (operands[0]) == MEM
		  && (GET_CODE (operands[1]) == MEM))
      {
		operands[1] = force_reg (QImode, operands[1]);
      }

   if (symbolic_memory_operand (operands[0], QImode) && !reload_in_progress)
	{
		  emit_insn (gen_storeqi (operands[0],operands[1]));
      	  DONE;
	}
	else if (symbolic_memory_operand (operands[1], QImode) 
			&& !reload_in_progress)
	{
   		 emit_insn (gen_storeqi (operands[0], operands[1]));
	 	 DONE;
	}
}")

/*
  In QImode

1) 
   destination can be ---> a,b,c,d,e,h,l,ixh,ixl,iyh,iyl,(hl),(ix+d)
   source can be     ---->  a,b,c,d,e,h,l,i

 2)
  one more set is
  destination can be --->      a,b,c,d,e
   source can be   ----->      a,b,c,d,e,ixh,ixl,iyh,iyl,i,(ix+d)

so, constraints are   
			r,hbdai
			U, hbdai  
			abd, abdxyi
			abd, U
			a, R
			R, a



 no
 ld iy, (ix+d)   and also ld (ix+d),iy
 ld h,ixh

*/

(define_insn "*movqi"          
  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,a,m,U,r")
	(match_operand:QI 1 "general_operand" "0,ri,m,a,ri,U"))]
 "GET_CODE (operands[1]) != SUBREG"
"*
{
if (which_alternative == 0)
  return \"nop\";
if (which_alternative == 1)    //r and ri
  return \"ld\\t%0,%1\";
if (which_alternative == 2)   //a and m
 return \"ld\\t%0,(%1)\";
if (which_alternative == 3)  // m and a
   return \"ld\\t(%0),%1\";
if (which_alternative == 4){  // U and r  
 return \"ld\\t(%0),%1\";
}
if (which_alternative == 5){ // r and U  
return \"ld\\t%0,(%1)\";  
}
}")
/* this needs to be examined closely, whenever truncating a SImode value to a QImode value it maps */

(define_insn ""
[(set (match_operand:QI 0 "nonimmediate_operand" "=m,r,r")
    (match_operand:QI 1 "general_operand" "r,m,r"))]
 "GET_CODE (operands[1]) == SUBREG"
"*
{
if (which_alternative ==0)
{
//operands[2] = gen_rtx_REG (QImode, HARD_A_REGNUM);
//output_asm_insn (\"ld\\t%2,%1\", operands);
return \"ld\\t(%0),%1\";
}
if (which_alternative == 1)
return \"ld\\t%0,(%1)\";
if (which_alternative == 2)
{
		return \"ld\\t%0,%2\";

}

}")
;; This can be made as loadstoreqi.

(define_insn "storeqi"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=a,r,R,R")
    (match_operand:QI 1 "general_operand" "R,R,a,r"))
   (clobber (match_scratch:QI 2 "=X,&a,X,&a"))]
  ""
  "*
{ 
	if (which_alternative == 0)
		return \"ld\\t%0,(%1)\";
	if (which_alternative == 1)
	{
		operands[2] = gen_rtx_REG (QImode, REGNO (operands[2]));
		output_asm_insn (\"ld\\t%2,(%1)\", operands);
		return \"ld\\t%0,%2\";
	}
	if (which_alternative == 2){
		return \"ld\\t(%0),%1\";
	}
	if (which_alternative == 3)
	{
		operands[2] = gen_rtx_REG (QImode, REGNO (operands[2]));
		output_asm_insn (\"ld\\t%2,%1\", operands);
		return \"ld\\t(%0),%2\";
	} 
}")






 (define_expand "reload_inqi"
  [(parallel [(set (match_operand:QI 0 "" "=r")
           (match_operand:QI 1 "symbolic_memory_operand" "m"))
          (clobber (match_operand:SI 2 "" "=&a"))])]
  ""
  "")
  
(define_expand "reload_outqi"
  [(parallel [(set (match_operand:QI 0 "symbolic_memory_operand" "=m")
           (match_operand:QI 1 "" "r"))
          (clobber (match_operand:SI 2 "" "=&a"))])]
  ""
  "")

(define_insn "swap_areg"
   [(set (match_operand:HI 0 "register_operand" "")
         (match_operand:HI 1 "register_operand" ""))
    (set (match_dup 1) (match_dup 0))]
   ""
   "ex\\t%0,%1")


(define_insn "zero_extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
        (zero_extend:SI 
	    (match_operand:HI 1 "register_operand" "r")))]   
  ""
  "#")

(define_split
  [(set (match_operand:SI 0 "register_operand" "=r")
	(zero_extend:SI 
	    (match_operand:HI 1 "register_operand" "r")))]
  "reload_completed"
[(set (match_dup 2) (match_dup 1))
 (set (match_dup 3) (const_int 0))]

"operands[2] = z80_gen_lowpart (HImode, operands[0]);
 operands[3] = z80_gen_highpart (HImode, operands[0]);
")

(define_insn "zero_extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
      (zero_extend:SI 
	  (match_operand:QI 1 "register_operand" "r")))]
  ""
  "#")

(define_split 
  [(set (match_operand:SI 0 "register_operand" "=r")
	(zero_extend:SI (match_operand:QI 1 "register_operand" "r")))]
  "reload_completed"
[(set (match_dup 4) (match_dup 1))
 (set (match_dup 5) (const_int 0))
 (set (match_dup 3) (const_int 0))]

"operands[2] = z80_gen_lowpart (HImode, operands[0]);
 operands[3] = z80_gen_highpart (HImode, operands[0]);
 operands[4] = z80_gen_lowpart (QImode, operands[2]);
 operands[5] = z80_gen_highpart (QImode, operands[2]);")


(define_insn "zero_extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(zero_extend:HI 
	    (match_operand:QI 1 "register_operand" "a")))]
  ""
 "#")

(define_split
[(set (match_operand:HI 0 "register_operand" "=r")
       (zero_extend:HI
               (match_operand:QI 1 "register_operand" "a")))]      
"reload_completed"

[(set (match_dup 2) (match_dup 1))
 (set (match_dup 3) (const_int 0))]            

 "operands[2] = z80_gen_lowpart (QImode, operands[0]);
 operands[3] = z80_gen_highpart (QImode, operands[0]);")

(define_insn "extendqihi2"
  [(set (match_operand:HI 0 "register_operand" "=r")
	(sign_extend:HI (match_operand:QI 1 "register_operand" "a")))]  
  ""
 "#")


(define_split
[(set (match_operand:HI 0 "register_operand" "=r")
       (sign_extend:HI (match_operand:QI 1 "register_operand" "a")))]
"reload_completed"
[(set (match_dup 2) (match_dup 1))
(set (match_dup 1) (rotate:QI (match_dup 1) (reg:QI 14)))   
(set (match_dup 1) (minus:QI (minus:QI (reg:QI 14) (match_dup 1)) (match_dup 1)))
(set (match_dup 3) (match_dup 1))]
"operands[2] = z80_gen_lowpart (QImode, operands[0]);
operands[3] = z80_gen_highpart (QImode, operands[0]);
")

/* doubt about this */

(define_insn "extendqisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(sign_extend:SI (match_operand:QI 1 "register_operand" "a")))]
  ""
"#")

(define_split
[(set (match_operand:SI 0 "register_operand" "=D")
       (sign_extend:SI (match_operand:QI 1 "register_operand" "a")))]
"reload_completed"
[(set (match_dup 2) (sign_extend:HI (match_dup 1)))      
 (set (match_dup 5) (match_dup 4))
 (set (match_dup 6) (match_dup 4))]

"operands[2] = z80_gen_lowpart (HImode, operands[0]);
 operands[3] = z80_gen_highpart (HImode, operands[0]);
 operands[4] = z80_gen_highpart (QImode, operands[2]);
 operands[5] = z80_gen_lowpart (QImode, operands[3]);
 operands[6] = z80_gen_highpart (QImode, operands[3]);
")


(define_insn "extendhisi2"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(sign_extend:SI (match_operand:HI 1 "register_operand" "b")))
	(clobber (match_scratch:QI 2 "=&a"))]
 ""
"#")

(define_split
[(set (match_operand:SI 0 "register_operand" "=D")
       (sign_extend:SI (match_operand:HI 1 "register_operand" "b")))  
	(clobber (match_scratch:QI 2 "=&a"))]
"reload_completed"
[(set (match_dup 8) (match_dup 5))   
(set  (match_dup 8) (rotate:QI (match_dup 8) (reg:QI 14)))
(set (match_dup 2) (minus:HI (minus:HI (reg:HI 14) (match_dup 2)) (match_dup 2)))
(set (match_dup 3) (match_dup 2))
(set (match_dup 2) (match_dup 1))]

"operands[2] = z80_gen_lowpart (HImode, operands[0]);
 operands[3] = z80_gen_highpart (HImode, operands[0]);  
 operands[4] = z80_gen_lowpart (QImode, operands[1]);
 operands[5] = z80_gen_highpart (QImode, operands[1]);
operands[6] = z80_gen_lowpart (QImode, operands[2]);
operands[7] = z80_gen_highpart (QImode, operands[2]);
operands[8] =  gen_rtx_REG (QImode, HARD_A_REGNUM);")






(define_insn "addsi3"
  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
	(plus:SI (match_operand:SI 1 "register_operand" "%0")
		 (match_operand:SI 2 "general_operand" "rmi")))
       (clobber (match_scratch:HI 3 "=&b"))])]
  ""
"#")
(define_split
[(parallel[(set (match_operand:SI 0 "register_operand" "=D")
       (plus:SI (match_operand:SI 1 "register_operand" "%0")
                (match_operand:SI 2 "general_operand" "rmi")))
     (clobber (match_scratch:HI 3 "=&b"))])]
"reload_completed"
[(set (match_dup 3) (match_dup 6))
(set (match_dup 4) (plus:HI (match_dup 4) (match_dup 3)))
(set (match_dup 3) (match_dup 7)) 
(parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))]) 
(set (match_dup 4) (plus:HI (plus:HI (reg:HI 14) (match_dup 4)) (match_dup 3)))
(parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))])] 

"operands[4]=z80_gen_lowpart(HImode,operands[1]);
 operands[5]=z80_gen_highpart(HImode,operands[1]);
 operands[6]=z80_gen_lowpart(HImode,operands[2]);
 operands[7]=z80_gen_highpart(HImode,operands[2]);")


(define_expand "addhi3"
[(set (match_operand:HI 0 "register_operand" "")
      (plus:HI (match_operand:HI 1 "register_operand" "")
                 (match_operand:HI 2 "general_operand" "")))]
""
"{
	if (SP_REG_P (operands[0]))
	{
		emit_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,
			 gen_rtx (SET, VOIDmode,
				  operands[0],gen_rtx (PLUS,HImode, operands[1],operands[2])), 
			gen_rtx (CLOBBER, VOIDmode,
				gen_rtx (SCRATCH, HImode)))));
		DONE;
	}
}")

(define_insn "addhi_sp"
[(parallel[(set (match_operand:HI 0 "stack_register_operand" "!w")
	  (plus:HI (match_operand:HI 1 "stack_register_operand" "0")
		        (match_operand:HI 2 "general_operand" "g"))) 
	(clobber (match_scratch:HI 3 "=&y"))])]
  
""
"*
{	operands[3] = gen_rtx_REG (HImode,HARD_IY_REGNUM);
	if (GET_CODE (operands[2]) == MEM)
	output_asm_insn (\"ld\\t%3,(%2)\", operands);
	else
	output_asm_insn (\"ld\\t%3,%2\", operands);
	output_asm_insn (\"add\\t%3,%0\", operands);
	output_asm_insn (\"ld\\t%0,%3\", operands);
	return \"\";

}")


(define_insn ""
[(set (match_operand:HI 0 "register_operand" "=r")
       (plus:HI (match_operand:HI 1 "register_operand" "0")
				 (const_int 1)))]  
""
"inc\\t%0")

(define_insn ""
[(set (match_operand:HI 0 "register_operand" "=r")
       (plus:HI (match_operand:HI 1 "register_operand" "0")
				 (const_int -1)))]  
""  
"dec\\t%0")

(define_insn "addhi_mov"
  [(set (match_operand:HI 0 "register_operand" "=hbdxy,xy")
	(plus:HI (match_operand:HI 1 "address_register" "!xy,0")
		 (match_operand:HI 2 "const_int_operand" "L,i")))]
  ""
  "*
{

	if (which_alternative ==0)
	{
		operands[3] = SET_SRC (PATTERN (insn));
		return \"lea\\t%0,%3\";  
	}
	if (which_alternative == 1)
	{
		operands[3] = gen_rtx_REG (HImode, HARD_BC_REGNUM);
		output_asm_insn (\"push\\t%3\", operands);
		output_asm_insn (\"ld\\t%3,%2\", operands);
		output_asm_insn (\"add\\t%0,%3\", operands);
		return \"pop\\t%3\";
	}
}")



/* In z80 add instruction allows hl,ix,iy as the first operand.
	bc,de,hl and sp as the second operand.
But still it will not allow add iy,hl or add ix,hl sequence.
	So, we need to be careful about it.  */

(define_insn "*addhi3"
  [(set (match_operand:HI 0 "register_operand" "=h,xy,hxy,bd,xy")    
	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,bd,0,0")
		 (match_operand:HI 2 "general_operand" "hbd!w,bd!w,mi,hxy,h")))]
  ""
  "*
{
switch (which_alternative)
{
	case 0:
		return \"add\\t%0,%2\";
    case 1:
		return \"add\\t%0,%2\";
	case 2:
		if (GET_CODE (operands[2]) == MEM)
			output_asm_insn (\"ld\\t%0,(%2)\", operands);
		else
			output_asm_insn (\"ld\\t%0,%2\", operands);
	    return \"add\\t%0,%1\";
	case 3:
		output_asm_insn (\"add\\t%2,%1\", operands);
		return \"ld\\t%1,%2\";
	case 4:
		operands[3] = gen_rtx_REG (HImode, HARD_E_REGNUM);
		output_asm_insn (\"ex\\t%2,%3\", operands);
		output_asm_insn (\"add\\t%3,%0\", operands);
		return\"ex\\t%2,%3\";   
	default:
		return \"\";
}
}")

(define_insn "*adch"
  [(set (match_operand:HI 0 "register_operand" "=h")
        (plus:HI (plus:HI (reg:HI 14)
                          (match_operand:HI 2 "register_operand" "%0"))
                 (match_operand:HI 3 "register_operand" "hbd!w")))]
  ""
  "adc\\t%0,%3")




(define_insn "addqi3"
  [(set (match_operand:QI 0 "register_operand" "=a,r,a")
	(plus:QI (match_operand:QI 1 "register_operand" "%0,0,0")
		 (match_operand:QI 2 "general_operand" "U,N,ri")))]
  ""
  "*
{
switch (which_alternative)
{
	case 0:
		return \"add\\t%0,(%2)\";
	case 1:
		if (INTVAL(operands[2]) == 1)
			return \"inc\\t%0\";
		else
			return \"dec\\t%0\";
	case 2:
		return \"add\\t%0,%2\";
	default:
		break;
}
}")

(define_insn "*adcq"
  [(set (match_operand:QI 0 "register_operand" "=a")
        (plus:QI (plus:QI (reg:QI 14)
                          (match_operand:QI 2 "register_operand" "%0"))
                 (match_operand:QI 3 "general_operand" "")))]
  ""
 "adc\\t%0,%3")

(define_insn "subsi3"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(minus:SI (match_operand:SI 1 "register_operand" "0")
		  (match_operand:SI 2 "general_operand" "rmi")))      
   (clobber (match_scratch:HI 3 "=&b"))]   
  ""
  "#")

;;-----------------------
 (define_split            
  [(set (match_operand:SI 0 "register_operand" "=D")
	(minus:SI (match_operand:SI 1 "register_operand" "0")
		  (match_operand:SI 2 "general_operand" "rmi")))   
                   (clobber (match_scratch:HI 3 "=&d"))]   
  "reload_completed && HL_REG_P (operands[1])"
  [(set (match_dup 3) (match_dup 6))  
  (set (match_dup 4) (minus:HI (match_dup 4) (match_dup 3)))
  (set (match_dup 3) (match_dup 7))
 (parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))]) 
(set  (match_dup 4) (minus:HI (minus:HI (reg:HI 14) (match_dup 4)) (match_dup 5)))
(parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))])] 
   "operands[4] = z80_gen_lowpart (HImode, operands[1]);
   operands[5] = z80_gen_highpart (HImode, operands[1]);
   operands[6] =z80_gen_lowpart (HImode, operands[2]);
   operands[7] =z80_gen_highpart (HImode, operands[2]);")

(define_insn "subhi3"
  [(set (match_operand:HI 0 "register_operand" "=h")
	(minus:HI (match_operand:HI 1 "register_operand" "%0")
		  (match_operand:HI 2 "register_operand" "hbd")))]
  ""
  "*
{
	operands[3] = gen_rtx_REG (QImode, HARD_A_REGNUM);
	output_asm_insn (\"or\\t%3,%3\", operands);
  return \"sbc\\t%0,%2\";
}")  

(define_insn "*subchi3"
  [(set (match_operand:HI 0 "register_operand" "=h")
	(minus:HI (minus:HI (reg:HI 14) 
                            (match_operand:HI 1 "register_operand" "%0"))
		  (match_operand:HI 2 "register_operand" "r")))]
  ""
  "sbc\\t%0,%2")

(define_insn "subqi3"
  [(set (match_operand:QI 0 "register_operand" "=a")
	(minus:QI (match_operand:QI 1 "register_operand" "%0")
		  (match_operand:QI 2 "general_operand" "Uri")))]
  ""
  "*
{
	if (GET_CODE (operands[2]) == MEM)
		return \"sub\\t%0,(%2)\";
	else
		return \"sub\\t%0,%2\";
}")   

(define_insn "*subcq"
  [(set (match_operand:QI 0 "register_operand" "=a")
        (minus:QI (minus:QI (reg:QI 14)
                            (match_operand:QI 2 "register_operand" "0"))
                  (match_operand:QI 3 "register_operand" "r")))]
  ""
  "sbc\\t%0,%3")

(define_insn "andsi3"
  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
	(and:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "general_operand" "Dim")))
         (clobber (match_scratch:QI 3 "=&a"))
         (clobber (match_scratch:HI 4 "=&b"))])]  
 ""
  "#")

(define_split 
  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
	(and:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "general_operand" "Dmi")))       
         (clobber (match_scratch:QI 3 "=&a"))  
         (clobber (match_scratch:HI 4 "=&b"))])] 
"reload_completed"
[(set (match_dup 4) (match_dup 7))
(parallel[(set (match_dup 5) (and:HI (match_dup 5) (match_dup 4))) (clobber (reg:QI 0))])      
 (set (match_dup 4) (match_dup 8))       
(parallel[(set (match_dup 6) (and:HI (match_dup 6) (match_dup 4))) (clobber (reg:QI 0))])]
   
"operands[4] = gen_rtx_REG (HImode, REGNO (operands[4]));
  operands[5] = z80_gen_lowpart (HImode, operands[1]);
   operands[6] = z80_gen_highpart (HImode, operands[1]);
   operands[7] = z80_gen_lowpart (HImode, operands[2]);
   operands[8] = z80_gen_highpart (HImode, operands[2]);")  


(define_insn "andhi3"
  [(parallel[(set (match_operand:HI 0 "register_operand" "=r")
	(and:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "register_operand" "r")))  
        (clobber (match_scratch:QI 3 "=a"))])]
  ""
"#")

(define_split 
  [(set (match_operand:HI 0 "register_operand" "=r")
	(and:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "register_operand" "r")))   
        (clobber (match_scratch:QI 3 "=a"))]
  "reload_completed"
 [(set (match_dup 3) (match_dup 4))
 (set (match_dup 3) (and:QI (match_dup 3) (match_dup 6) ))   
 (set (match_dup 4) (match_dup 3))
 (set (match_dup 3) (match_dup 5))
 (set (match_dup 3) (and:QI (match_dup 3) (match_dup 7) ))
 (set (match_dup 5) (match_dup 3))]
"operands[4] = z80_gen_lowpart (QImode,operands[1] );
   operands[5] = z80_gen_highpart (QImode, operands[1]);
   operands[6] = z80_gen_lowpart (QImode,operands[2]);
   operands[7] = z80_gen_highpart (QImode, operands[2]);") 

(define_insn "andqi3"
  [(set (match_operand:QI 0 "register_operand" "=a")
        (and:QI (match_operand:QI 1 "register_operand" "%0")
             (match_operand:QI 2 "general_operand" "U*ri")))]
  ""
  "*
{
	if (GET_CODE (operands[2]) == CONST_INT)
    {
      int val = INTVAL (operands[2]) & 0x0FF;

      if (val == 0xFF)
    {
      cc_status = cc_prev_status;
      return \"\";
    }
	if (val == 0)
		return \"ld\\t%0,0\";
	return \"and\\t%0,%1\";
	}

if (GET_CODE (operands[2]) == MEM)
	return\"and\\t%1,(%2)\";
else
	return \"and\\t%1,%2\";

}")

(define_insn "iorsi3"
  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
	(ior:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "general_operand" "Dim")))
         (clobber (match_scratch:QI 3 "=&a"))
         (clobber (match_scratch:HI 4 "=&b"))])]  
 ""
  "#")

(define_split 
  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
	(ior:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "general_operand" "Dmi")))       
         (clobber (match_scratch:QI 3 "=&a"))  
         (clobber (match_scratch:HI 4 "=&b"))])] 
"reload_completed"
[(set (match_dup 4) (match_dup 7))
(parallel[(set (match_dup 5) (ior:HI (match_dup 5) (match_dup 4))) (clobber (reg:QI 0))])      
 (set (match_dup 4) (match_dup 8))       
(parallel[(set (match_dup 6) (ior:HI (match_dup 6) (match_dup 4))) (clobber (reg:QI 0))])]
   
"operands[4] = gen_rtx_REG (HImode, REGNO (operands[4]));
  operands[5] = z80_gen_lowpart (HImode, operands[1]);
   operands[6] = z80_gen_highpart (HImode, operands[1]);
   operands[7] = z80_gen_lowpart (HImode, operands[2]);
   operands[8] = z80_gen_highpart (HImode, operands[2]);")  


(define_insn "iorhi3"
  [(parallel[(set (match_operand:HI 0 "register_operand" "=r")
	(ior:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "register_operand" "r")))  
        (clobber (match_scratch:QI 3 "=a"))])]
  ""
"#")

(define_split 
  [(set (match_operand:HI 0 "register_operand" "=r")
	(ior:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "register_operand" "r")))   
        (clobber (match_scratch:QI 3 "=a"))]
  "reload_completed"
 [(set (match_dup 3) (match_dup 4))
 (set (match_dup 3) (ior:QI (match_dup 3) (match_dup 6) ))   
 (set (match_dup 4) (match_dup 3))
 (set (match_dup 3) (match_dup 5))
 (set (match_dup 3) (ior:QI (match_dup 3) (match_dup 7) ))
 (set (match_dup 5) (match_dup 3))]
"operands[4] = z80_gen_lowpart (QImode,operands[1] );
   operands[5] = z80_gen_highpart (QImode, operands[1]);
   operands[6] = z80_gen_lowpart (QImode,operands[2]);
   operands[7] = z80_gen_highpart (QImode, operands[2]);") 

(define_insn "iorqi3"
  [(set (match_operand:QI 0 "register_operand" "=a")
	(ior:QI (match_operand:QI 1 "register_operand" "%0")
	     (match_operand:QI 2 "general_operand" "rUi")))]
  ""
 "*
{
if (GET_CODE (operands[2]) == CONST_INT)
    {
      int val = INTVAL (operands[2]) & 0x0FF;

      if (val == 0)
    {
      cc_status = cc_prev_status;
      return \"\";
    }
	return \"or\\t%0,%1\";
}

if (GET_CODE (operands[2]) == MEM)
 	return \"or\\t%1,(%2)\";
else
 	return \"or\\t%1,%2\";
}")

(define_insn "xorsi3"
  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
	(xor:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "general_operand" "Dim")))
         (clobber (match_scratch:QI 3 "=&a"))
         (clobber (match_scratch:HI 4 "=&b"))])]  
 ""
  "#")

(define_split 
  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
	(xor:SI (match_operand:SI 1 "register_operand" "%0")
		(match_operand:SI 2 "general_operand" "Dmi")))       
         (clobber (match_scratch:QI 3 "=&a"))  
         (clobber (match_scratch:HI 4 "=&b"))])] 
"reload_completed"
[(set (match_dup 4) (match_dup 7))
(parallel[(set (match_dup 5) (xor:HI (match_dup 5) (match_dup 4))) (clobber (reg:QI 0))])      
 (set (match_dup 4) (match_dup 8))       
(parallel[(set (match_dup 6) (xor:HI (match_dup 6) (match_dup 4))) (clobber (reg:QI 0))])]
   
"operands[4] = gen_rtx_REG (HImode, REGNO (operands[4]));
  operands[5] = z80_gen_lowpart (HImode, operands[1]);
   operands[6] = z80_gen_highpart (HImode, operands[1]);
   operands[7] = z80_gen_lowpart (HImode, operands[2]);
   operands[8] = z80_gen_highpart (HImode, operands[2]);")  


(define_insn "xorhi3"
  [(parallel[(set (match_operand:HI 0 "register_operand" "=r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "register_operand" "r")))  
        (clobber (match_scratch:QI 3 "=a"))])]
  ""
"#")

(define_split 
  [(set (match_operand:HI 0 "register_operand" "=r")
	(xor:HI (match_operand:HI 1 "register_operand" "%0")
		(match_operand:HI 2 "register_operand" "r")))   
        (clobber (match_scratch:QI 3 "=a"))]
  "reload_completed"
 [(set (match_dup 3) (match_dup 4))
 (set (match_dup 3) (xor:QI (match_dup 3) (match_dup 6) ))   
 (set (match_dup 4) (match_dup 3))
 (set (match_dup 3) (match_dup 5))
 (set (match_dup 3) (xor:QI (match_dup 3) (match_dup 7) ))
 (set (match_dup 5) (match_dup 3))]
"operands[4] = z80_gen_lowpart (QImode,operands[1] );
   operands[5] = z80_gen_highpart (QImode, operands[1]);
   operands[6] = z80_gen_lowpart (QImode,operands[2]);
   operands[7] = z80_gen_highpart (QImode, operands[2]);") 

(define_insn "xorqi3"
  [(set (match_operand:QI 0 "register_operand" "=a")
        (xor:QI (match_operand:QI 1 "register_operand" "%0")
             (match_operand:QI 2 "general_operand" "rUi")))]
  ""
"*
{
 if (GET_CODE (operands[2]) == CONST_INT)
    {
      int val = INTVAL (operands[2]) & 0x0FFFF;

      if (val == 0)
    {
      cc_status = cc_prev_status;
      return \"\";
    }
	CC_STATUS_INIT;
	return \"xor\\t%0,%1\";
}
CC_STATUS_INIT;
if (GET_CODE (operands[2]) == MEM)
	return \"xor\\t%1,(%2)\";
else
   return \"xor\\t%1,%2\";
}")

(define_insn "negsi2"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(neg:SI (match_operand:SI 1 "nonimmediate_operand" "0")))   
       (clobber (match_scratch:HI 2 "=&b"))]
""
  "#")
(define_split
 [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
       (neg:SI (match_operand:SI 1 "nonimmediate_operand" "0")))    
   (clobber (match_scratch:HI 2 "=&b"))]
"reload_completed"
[(set (match_dup 2) (match_dup 3))
(parallel[(set (match_dup 2) (neg:HI (match_dup 2))) (clobber (match_dup 3))])
(set (match_dup 3) (const_int 0))   
(set  (match_dup 3) (minus:HI (minus:HI (reg:HI 14) (match_dup 3)) (match_dup 4)))
 (set (match_dup 4) (match_dup 3))
(set  (match_dup 3) (match_dup 2))]
"operands[3]=z80_gen_lowpart(HImode,operands[0]);
 operands[4]=z80_gen_highpart(HImode,operands[0]);")


;;-----------------------
(define_insn "neghi2"
  [(set (match_operand:HI 0 "register_operand" "=bd")
	(neg:HI (match_operand:HI 1 "register_operand" "0")))    
      (clobber (match_scratch:HI 2 "=&h"))]
"" 
"#")
(define_split
[(set (match_operand:HI 0 "register_operand" "=r")
      (neg:HI (match_operand:HI 1 "register_operand" "0")))         
    (clobber (match_scratch:HI 2 "=&h"))]

"reload_completed" 
[(set (match_dup 2) (const_int 0))   
 (set (match_dup 2) (minus:HI (match_dup 2) (match_dup 1)))
 (set (match_dup 0) (match_dup 2))]

"")

(define_insn "negqi2"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=a")
	(neg:QI (match_operand:QI 1 "nonimmediate_operand" "0")))]
  ""
 "neg")

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(not:SI (match_operand:SI 1 "register_operand" "0")))    
    (clobber (match_scratch:HI 2 "=&b"))]     
 ""
 "#")
(define_split
[(set (match_operand:SI 0 "register_operand" "=r")
       (not:SI (match_operand:SI 1 "register_operand" "0")))   
     (clobber (match_scratch:HI 2 "=&b"))]
"reload_completed"
[(set (match_dup 2) (match_dup 3))
(parallel[(set (match_dup 2) (not:HI (match_dup 2))) (clobber (match_dup 3))])
(set (match_dup 3) (const_int -1))   
(set  (match_dup 3) (minus:HI (minus:HI (reg:HI 14) (match_dup 3)) (match_dup 4)))
 (set (match_dup 4) (match_dup 3))
(set (match_dup 3) (match_dup 2))]
"operands[3]=z80_gen_lowpart(HImode, operands[0]);
 operands[4]=z80_gen_highpart(HImode, operands[0]);")

;;-----------------------
(define_insn "one_cmplhi2"
  [(set (match_operand:HI 0 "register_operand" "=bd")
	(not:HI (match_operand:HI 1 "register_operand" "0")))
   (clobber (match_scratch:HI 2 "=&h"))] 
 ""
 "#")
(define_split
 [(set (match_operand:HI 0 "register_operand" "=bd")
        (not:HI (match_operand:HI 1 "register_operand" "0")))
    (clobber (match_scratch:HI 2 "=&h"))]
"reload_completed"
[(set (match_dup 2) (const_int -1))
 (set (match_dup 2) (minus:HI (match_dup 2) (match_dup 1)))
(set (match_dup 1) (match_dup 2))]
"")

;;-----------------------
(define_insn "one_cmplqi2"
  [(set (match_operand:QI 0 "non_push_operand" "=a")
	(not:QI (match_operand:QI 1 "general_operand" "0")))]
 ""
 "cpl")


;; Probably I need to make a library call in side the shift patterns.
;;So that size of this file will be less. ?? (for SImode).

;;need to make some of the shifts as library calls. (libgcc1.).
;; So that  the code size won't grow.


(define_expand "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(ashift:SI (match_operand:SI 1 "register_operand" "")
	           (match_operand:HI 2 "general_operand" "")))]
  ""
 "")


(define_insn "ashlsi3_const1"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(ashift:SI (match_operand:SI 1 "register_operand" "0")
	           (const_int 1)))]
  ""
  "*
  {
 operands[3] = z80_gen_lowpart(HImode, operands[0]);
 operands[4] = z80_gen_highpart(HImode, operands[0]);
 operands[5] = z80_gen_lowpart(QImode, operands[3]);
 operands[6] = z80_gen_highpart(QImode, operands[3]);
 operands[7] = z80_gen_lowpart(QImode, operands[4]);
 operands[8] = z80_gen_highpart(QImode, operands[4]);
	output_asm_insn (\"sla\\t%5\", operands);
	output_asm_insn (\"rl\\t%6\", operands);
	output_asm_insn (\"rl\\t%7\", operands);
  return \"rl\\t%8\";
}")

(define_insn "*ashlsi3_const16"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(ashift:SI (match_operand:SI 1 "register_operand" "0")
	           (const_int 16)))]
  ""
  "*
  {
 operands[3] = z80_gen_lowpart(HImode, operands[0]);
 operands[4] = z80_gen_highpart(HImode, operands[0]);

output_asm_insn (\"ld\\t%4,%3\", operands);
 return \"ld\\t%3,0\";
}")


(define_insn "*ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(ashift:SI (match_operand:SI 1 "register_operand" "0")
	           (match_operand:HI 2 "general_operand" "b")))]
   ""
   "*
{
  rtx label[2];

  
CC_STATUS_INIT;
 operands[3] = z80_gen_lowpart (QImode, operands[2]);
 operands[4] = z80_gen_highpart (QImode, operands[2]);
output_asm_insn (\"ld\\t%4,%3\", operands);
  operands[5] = z80_gen_lowpart (HImode, operands[0]);
  operands[6] = z80_gen_highpart (HImode, operands[0]);
 operands[7] = z80_gen_lowpart(QImode, operands[5]);
 operands[8] = z80_gen_highpart(QImode, operands[5]);
 operands[9] = z80_gen_lowpart(QImode, operands[6]);
 operands[10] = z80_gen_highpart(QImode, operands[6]);
	label[0] = gen_label_rtx ();
	label[1] = gen_label_rtx ();

	output_asm_insn (\"inc\\t%4\",operands);
	output_asm_insn (\"dec\\t%4\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[0]));
	output_asm_insn (\"sla\\t%7\", operands);
	output_asm_insn (\"rl\\t%8\", operands);
	output_asm_insn (\"rl\\t%9\", operands);
	output_asm_insn (\"rl\\t%10\", operands);
	output_asm_insn (\"djnz\\t%l0\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[1]));

   return \"\";
}")

(define_expand "ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(ashift:HI (match_operand:HI 1 "register_operand" "")
	           (match_operand:HI 2 "general_operand" "")))]
   ""
   "")

(define_insn "*ashlhi3_const1"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(ashift:HI (match_operand:HI 1 "register_operand" "0")
	           (const_int 1)))]
  ""
  "*
{
operands[2]= z80_gen_lowpart (QImode, operands[0]);
operands[3]= z80_gen_highpart (QImode, operands[0]);
output_asm_insn (\"sla\\t%2\", operands);
output_asm_insn (\"rl\\t%3\", operands);
return\"\";
}")
/* just check the output when the shift count is 15. */

(define_insn "*ashlhi3_const"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(ashift:HI (match_operand:HI 1 "register_operand" "0")
	           (match_operand:HI 2 "const_int_operand" "")))]
  ""
  "*
{
  int	i;
	
	operands[3] = z80_gen_lowpart (QImode, operands[0]);
	operands[4] = z80_gen_highpart (QImode, operands[1]);
	
  i = INTVAL (operands[2]);
  if (i >= 8)
    {
      CC_STATUS_INIT;
      output_asm_insn (\"ld\\t%4,%3\", operands);
      if (i == 15)
        {
	  output_asm_insn (\"rr\\t%4\", operands);
	  output_asm_insn (\"ld\\t%4,0\", operands);
	  output_asm_insn (\"rr\\t%4\", operands);
	}
      else
        while (i != 8 )
          {
            output_asm_insn (\"sla\\t%4\", operands);
	    i--;
	  }
      return \"ld\\t%3,0\";
    }
  for (i = 0; i < INTVAL (operands[2]); i++) 
    {
      output_asm_insn (\"sla\\t%3\", operands);
      output_asm_insn (\"rl\\t%4\", operands);
    }
  return \"\";
}")

(define_insn "*ashlhi3"
  [(set (match_operand:HI 0 "register_operand" "=hd")
	(ashift:HI (match_operand:HI 1 "register_operand" "0")
	           (match_operand:HI 2 "general_operand" "b")))]   
 
""
  "*
{
  rtx label[2];
operands[3] = z80_gen_lowpart (QImode, operands[1]);
 operands[4] = z80_gen_highpart (QImode, operands[1]);
  
operands[5] = z80_gen_lowpart  (QImode, operands[2]);
 operands[6] = z80_gen_highpart (QImode, operands[2]);
	output_asm_insn (\"ld\\t%6,%5\", operands);
	
    label[0] = gen_label_rtx ();
	label[1] = gen_label_rtx ();
	output_asm_insn (\"inc\\t%6\",operands);
	output_asm_insn (\"dec\\t%6\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[0]));
	output_asm_insn (\"sla\\t%3\", operands);
	output_asm_insn (\"rl\\t%4\", operands);
	output_asm_insn (\"djnz\\t%l0\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[1]));

	return\"\";
}")

;;-----------------------

(define_expand "ashlqi3"
  [(set (match_operand:QI 0 "register_operand" "")
    (ashift:QI (match_operand:QI 1 "register_operand" "")
               (match_operand:QI 2 "general_operand" "")))]
   ""
"")

(define_insn "*ashlqi3_const1"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbda")
	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0")
	           (const_int 1)))]
  ""
  "sla\\t%0")


(define_insn "*ashlqi3_const"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbda")
	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0")
	           (match_operand:QI 2 "const_int_operand" "")))]
  ""
  "*
{
  int i;
  i = INTVAL(operands[2]);
  if (i >= 8)
    {
     return \"ld\\t%0,0\";
   }
  else if (i == 7)
    {
          output_asm_insn (\"rr\\t%0\", operands);
          output_asm_insn (\"ld\\t%0,0\", operands);
          return \"rr\\t%0\";
    }
  while (--i >= 0)
    {
      output_asm_insn (\"sla\\t%0\", operands);
    }
  return \"\";
}")
/* here there is a problem  if the operands[2] is going to be a symbolic memory 
variable we can not get that in register b.
  But any way that case is not being mapped to ashlqi3 ( bramha )
*/

(define_insn "*ashlqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=hda")
	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0")
            (match_operand:QI 2 "nonimmediate_operand" "b")))]
  ""
  "*
{
 rtx label[2];
 
CC_STATUS_INIT;

label[0]  = gen_label_rtx ();
label[1] = gen_label_rtx ();
operands[2] = gen_rtx_REG (QImode, HARD_B_REGNUM);
operands[3] = gen_rtx_REG (QImode, HARD_C_REGNUM);
output_asm_insn (\"ld\\t%2,%3\", operands);
output_asm_insn (\"inc\\t%2\", operands);
output_asm_insn (\"dec\\t%2\", operands);
output_asm_insn (\"jr\\tz,%l1\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[0]));
output_asm_insn (\"sla\\t%0\", operands);
output_asm_insn (\"djnz\\t%l0\", label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[1]));

 return \"\";

}")

(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "")
	             (match_operand:HI 2 "general_operand" "")))]
  
 ""
 "")

;;-----------------------
(define_insn "*ashrsi3_const1"
  [(set (match_operand:SI 0 "non_push_operand" "=D")
	(ashiftrt:SI (match_operand:SI 1 "non_push_operand" "0")
	             (const_int 1)))]
  ""
"* 
{
 operands[3] = z80_gen_lowpart(HImode, operands[0]);
 operands[4] = z80_gen_highpart(HImode, operands[0]);
 operands[5] = z80_gen_lowpart(QImode, operands[3]);
 operands[6] = z80_gen_highpart(QImode, operands[3]);
 operands[7] = z80_gen_lowpart(QImode, operands[4]);
 operands[8] = z80_gen_highpart(QImode, operands[4]);
	output_asm_insn (\"sra\\t%8\", operands);
	output_asm_insn (\"rr\\t%7\", operands);
	output_asm_insn (\"rr\\t%6\", operands);
  return \"rr\\t%5\";

}")

(define_insn "*ashrsi3"
[(set (match_operand:SI 0 "register_operand" "=D")
       (ashiftrt:SI (match_operand:SI 1 "register_operand" "0")
					(match_operand:HI 2 "general_operand" "b")))]
""
"*
{
 rtx label[2];
 operands[3] = z80_gen_lowpart (QImode, operands[2]);
 operands[4] = z80_gen_highpart (QImode, operands[2]);
output_asm_insn (\"ld\\t%4,%3\", operands);
  operands[5] = z80_gen_lowpart (HImode, operands[0]);
  operands[6] = z80_gen_highpart (HImode, operands[0]);
 operands[7] = z80_gen_lowpart(QImode, operands[5]);
 operands[8] = z80_gen_highpart(QImode, operands[5]);
 operands[9] = z80_gen_lowpart(QImode, operands[6]);
 operands[10] = z80_gen_highpart(QImode, operands[6]);
	
	label[0] = gen_label_rtx ();
	label[1] = gen_label_rtx ();
	
    output_asm_insn (\"inc\\t%4\",operands);
	output_asm_insn (\"dec\\t%4\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[0]));
  
	output_asm_insn (\"sra\\t%10\", operands);
	output_asm_insn (\"rr\\t%9\", operands);
	output_asm_insn (\"rr\\t%8\", operands);
	output_asm_insn (\"rr\\t%7\", operands);
	output_asm_insn (\"djnz\\t%l0\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[1]));

		return \"\";


}")

(define_expand "ashrhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "")
	             (match_operand:HI 2 "general_operand" "")))]
   ""
   "")


;;-----------------------
(define_insn "*ashrhi3_const1"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0")
	             (const_int 1)))]
  ""
  "*
{
  CC_STATUS_INIT;
operands[2]= z80_gen_lowpart (QImode, operands[0]);
operands[3]= z80_gen_highpart (QImode, operands[0]);
output_asm_insn (\"sra\\t%3\", operands);
output_asm_insn (\"rr\\t%2\", operands);
return\"\";
}")

(define_insn "*ashrhi3"
  [(set (match_operand:HI 0 "nonimmediate_operand" "=hb")
	(ashiftrt:HI (match_operand:HI 1 "nonimmediate_operand" "0")
     (match_operand:HI 2 "general_operand" "b")))]
  ""
  "*
{
 rtx label[2];

  CC_STATUS_INIT;
operands[3] = z80_gen_lowpart (QImode, operands[1]);
 operands[4] = z80_gen_highpart (QImode, operands[1]);
  
operands[5] = z80_gen_lowpart  (QImode, operands[2]);
 operands[6] = z80_gen_highpart (QImode, operands[2]);
	output_asm_insn (\"ld\\t%6,%5\", operands);
	
    label[0] = gen_label_rtx ();
	label[1] = gen_label_rtx ();
 
 label[0] = gen_label_rtx ();
  label[1] = gen_label_rtx ();
	output_asm_insn (\"inc\\t%6\", operands);
	output_asm_insn (\"dec\\t%6\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
			     CODE_LABEL_NUMBER (label[0]));

  output_asm_insn (\"sra\\t%4\", operands);
  output_asm_insn (\"rr\\t%3\", operands);
  output_asm_insn (\"djnz\\t%l0\", label);

  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
			     CODE_LABEL_NUMBER (label[1]));
  return \"\";
}")

(define_expand "ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "")
	             (match_operand:QI 2 "general_operand" "")))]
   ""
   "")


;;-----------------------
(define_insn "*ashrqi3_const1"
  [(set (match_operand:QI 0 "register_operand" "=hbda")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
		     (const_int 1)))]
  ""
"sra\\t%0")

(define_insn "*ashrqi3_const"
  [(set (match_operand:QI 0 "register_operand" "=hbda")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
	             (match_operand:QI 2 "const_int_operand" "")))]
  ""
  "*
{
  int i;
  i = INTVAL (operands[2]);
  if (i > 8)
    i = 8;
  while (--i >= 0)
    {
      output_asm_insn (\"sra\\t%0\", operands);
    }
  return \"\";
}")

;; you need register b to keep the count. It will fail to load symbolic
;; memory in to register b, that case not being mapped to ashrqi, they are
;; mapped to ashrsi (the values are sign extended and being mapped to ashrhi */


(define_insn "*ashrqi3"
  [(set (match_operand:QI 0 "register_operand" "=hda")
	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
	    (match_operand:QI 2 "nonimmediate_operand" "b")))]
  ""
  "*
{
 rtx label[2];
 
CC_STATUS_INIT;

label[0]  = gen_label_rtx ();
label[1] = gen_label_rtx ();
operands[2] = gen_rtx_REG (QImode, HARD_B_REGNUM);
operands[3] = gen_rtx_REG (QImode, HARD_C_REGNUM);
output_asm_insn (\"ld\\t%2,%3\", operands);
output_asm_insn (\"inc\\t%2\", operands);
output_asm_insn (\"dec\\t%2\", operands);
	output_asm_insn (\"inc\\t%2\", operands);
	output_asm_insn (\"dec\\t%2\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[0]));

output_asm_insn (\"sra\\t%0\", operands);
output_asm_insn (\"djnz\\t%l0\", label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[1]));

 return \"\";

}")

(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "")
	             (match_operand:HI 2 "general_operand" "")))] 
  
 ""
"")

;;-----------------------
(define_insn "*lshrsi3_const1"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
	             (const_int 1)))]
   
  ""
 "*
{
operands[3] = z80_gen_lowpart(HImode, operands[0]);
 operands[4] = z80_gen_highpart(HImode, operands[0]);
 operands[5] = z80_gen_lowpart(QImode, operands[3]);
 operands[6] = z80_gen_highpart(QImode, operands[3]);
 operands[7] = z80_gen_lowpart(QImode, operands[4]);
 operands[8] = z80_gen_highpart(QImode, operands[4]);
	output_asm_insn (\"srl\\t%8\", operands);
	output_asm_insn (\"rr\\t%7\", operands);
	output_asm_insn (\"rr\\t%6\", operands);
  return \"rr\\t%5\";

}")

(define_insn "*lshrsi3_const16"
  [(set (match_operand:SI 0 "register_operand" "=r")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
	             (const_int 16)))]
   
  ""
 "*
{
operands[3] = z80_gen_lowpart(HImode, operands[0]);
 operands[4] = z80_gen_highpart(HImode, operands[0]);
output_asm_insn (\"ld\\t%3,%4\", operands);
 return \"ld\\t%4,0\";
}")


(define_insn "*lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "=D")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
                 (match_operand:HI 2 "general_operand" "b")))]  
  ""
"*
{
 rtx label[2];

CC_STATUS_INIT;
 operands[3] = z80_gen_lowpart (QImode, operands[2]);
 operands[4] = z80_gen_highpart (QImode, operands[2]);
output_asm_insn (\"ld\\t%4,%3\", operands);
  operands[5] = z80_gen_lowpart (HImode, operands[0]);
  operands[6] = z80_gen_highpart (HImode, operands[0]);
 operands[7] = z80_gen_lowpart(QImode, operands[5]);
 operands[8] = z80_gen_highpart(QImode, operands[5]);
 operands[9] = z80_gen_lowpart(QImode, operands[6]);
 operands[10] = z80_gen_highpart(QImode, operands[6]);
	label[0] = gen_label_rtx ();
	label[1] = gen_label_rtx ();

	output_asm_insn (\"inc\\t%4\",operands);
	output_asm_insn (\"dec\\t%4\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[0]));
	output_asm_insn (\"srl\\t%10\", operands);
	output_asm_insn (\"rr\\t%9\", operands);
	output_asm_insn (\"rr\\t%8\", operands);
	output_asm_insn (\"rr\\t%7\", operands);
	output_asm_insn (\"djnz\\t%l0\",label);
 ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (label[1]));

   return \"\";
}")

;;-----------------------
(define_expand "lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "")
	             (match_operand:HI 2 "general_operand" "")))]
   ""
 "")



;;-----------------------
(define_insn "lshrhi3_const1"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
		     (const_int 1)))]
  ""
  "*
{
  CC_STATUS_INIT;
operands[2]= z80_gen_lowpart (QImode, operands[0]);
operands[3]= z80_gen_highpart (QImode, operands[0]);
output_asm_insn (\"srl\\t%3\", operands);
output_asm_insn (\"rr\\t%2\", operands);
return\"\";
}")

(define_insn ""
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
		     (const_int 8)))]
  ""
  "*
{
  CC_STATUS_INIT;
operands[2]=gen_rtx_REG (QImode, REGNO(operands[0]));
operands[3]=gen_rtx_REG (QImode, REGNO(operands[0])+1);
output_asm_insn (\"ld\\t%2,%3\", operands);
output_asm_insn (\"ld\\t%3,0\", operands);
return\"\";
}")

;;-----------------------

(define_insn "*lshrhi3"
  [(set (match_operand:HI 0 "register_operand" "=hd")
	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
		(match_operand:HI 2 "general_operand" "b")))]
  ""
  "*
{
 rtx label[2];
  CC_STATUS_INIT;
operands[3] = z80_gen_lowpart (QImode, operands[1]);
 operands[4] = z80_gen_highpart (QImode, operands[1]);
  
operands[5] = z80_gen_lowpart  (QImode, operands[2]);
 operands[6] = z80_gen_highpart (QImode, operands[2]);
	output_asm_insn (\"ld\\t%6,%5\", operands);
	
    label[0] = gen_label_rtx ();
	label[1] = gen_label_rtx ();
 
	output_asm_insn (\"inc\\t%6\", operands);
	output_asm_insn (\"dec\\t%6\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
			     CODE_LABEL_NUMBER (label[0]));

  output_asm_insn (\"srl\\t%4\", operands);
  output_asm_insn (\"rr\\t%3\", operands);
  output_asm_insn (\"djnz\\t%l0\", label);

  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
			     CODE_LABEL_NUMBER (label[1]));
  return \"\";
}")

(define_expand "lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "")
	             (match_operand:QI 2 "general_operand" "")))]
   ""
  "")


;;-----------------------
(define_insn "*lshrqi3_const1"
  [(set (match_operand:QI 0 "register_operand" "=ahd")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
		     (const_int 1)))]
 ""
  "srl\\t%0")


;;-----------------------

(define_insn "*lshrqi3"
  [(set (match_operand:QI 0 "register_operand" "=ahd")
	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
     (match_operand:QI 2 "nonimmediate_operand" "b")))]
  ""
  "*
{
 rtx label[2];

  CC_STATUS_INIT;
  label[0] = gen_label_rtx ();
  label[1] = gen_label_rtx ();
operands[2] = gen_rtx_REG (QImode, HARD_B_REGNUM);
operands[3] = gen_rtx_REG (QImode, HARD_C_REGNUM);
output_asm_insn (\"ld\\t%2,%3\", operands);
	output_asm_insn (\"inc\\t%2\",operands);
	output_asm_insn (\"dec\\t%2\", operands);
	output_asm_insn (\"jr\\tz,%l1\",label);
  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
			     CODE_LABEL_NUMBER (label[0]));

  output_asm_insn (\"srl\\t%1\", operands);
  output_asm_insn (\"djnz\\t%l0\", label);

  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
			     CODE_LABEL_NUMBER (label[1]));
  return \"\";

}")

;; These rotate patterns (?? when are they get invoked)
;; In some of the splits for shifts and extendm1m2 patterns I am explicitly
;; invoking rotate with carry patterns for qimode.
;; Rest of them are not being used.
;; 

(define_insn "*rotlqi3_with_carry"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbdaU")
	(rotate:QI (match_operand:QI 1 "nonimmediate_operand" "0")
		   (reg:QI 14)))]
  ""
  "*
{
if (GET_CODE (operands[0]) == MEM)
      return \"rl\\t(%0)\";                   
else
return \"rl\\t%0\";

}")

/* not really needed */

;;-----------------------
(define_insn "*rotlhi3_with_carry"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(rotate:HI (match_operand:HI 1 "register_operand" "0")
		   (reg:HI 14)))]
  ""
  "*
{
operands[3]=z80_gen_lowpart(QImode, operands[0]);
operands[4]=z80_gen_highpart(QImode, operands[0]);
 output_asm_insn (\"rl\\t%3\", operands);
output_asm_insn (\"rl\\t%4\", operands);
return \"\";
}")




;;-----------------------


(define_insn "*rotrqi3_with_carry"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbdaU")
	(rotatert:QI (match_operand:QI 1 "nonimmediate_operand" "0")
		     (reg:QI 14)))]
  ""
  "*
{
  CC_STATUS_INIT;
if (GET_CODE (operands[0]) == MEM)
     return \"rr\\t(%0)\";
else
return\"rr\\t%0\";

}")

(define_insn "*rotrhi3_with_carry"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(rotatert:HI (match_operand:HI 1 "register_operand" "0")
		     (reg:HI 14)))]
  ""
  "#")

(define_split
 [(set (match_operand:HI 0 "register_operand" "=hbd")
       (rotatert:HI (match_operand:HI 1 "register_operand" "0")
                     (reg:HI 14)))]
"reload_completed"
[(set (match_dup 2) (rotatert:QI (match_dup 2) (reg:QI 8)))
  (set (match_dup 3) (rotatert:QI (match_dup 3) (reg:QI 8)))]

"operands[2]=z80_gen_lowpart(QImode, operands[0]);
 operands[3]=z80_gen_highpart(QImode, operands[0]);
")

;; It is not clear when these rtl patterns are mapped. So, just left it
;like that. Need to implement them.


(define_insn "rotlqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=ahbdU")
	(rotate:QI (match_operand:QI 1 "nonimmediate_operand" "0")
		   (match_operand:QI 2 "const_int_operand" "i")))]
  ""
  "*
{
 // z80_gen_rotate (ROTATE, insn, operands);
  return \"rlc\\t%0\";
}")


;;-----------------------
(define_insn "rotlhi3"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(rotate:HI (match_operand:HI 1 "register_operand" "0")
		   (match_operand:HI 2 "const_int_operand" "i")))]
  ""
  "*
{
// z80_gen_rotate (ROTATE, insn, operands);
  return \"rlc\\t%0\";
}")


;;-----------------------
(define_insn "rotrqi3"
  [(set (match_operand:QI 0 "nonimmediate_operand" "=ahbdU")
	(rotatert:QI (match_operand:QI 1 "nonimmediate_operand" "0")
		     (match_operand:QI 2 "const_int_operand" "i")))]
  ""
  "*
{
 // z80_gen_rotate (ROTATERT, insn, operands);
  return \"rra\";
}")


;;-----------------------
(define_insn "rotrhi3"
  [(set (match_operand:HI 0 "register_operand" "=hbd")
	(rotatert:HI (match_operand:HI 1 "register_operand" "0")
		     (match_operand:HI 2 "const_int_operand" "i")))]
  ""
  "*
{
 // z80_gen_rotate (ROTATERT, insn, operands);
  return \"rrc\\t%0\";
}")

;;--------------------------------------------------------------------



;;- nop instruction
(define_insn "nop"
  [(const_int 0)]
  ""
  "nop")

;; Unconditional and other jump instructions
(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jp\\t%l0")

(define_expand "tablejump"
  [(parallel [(set (pc) (match_operand 0 "" ""))
          (use (label_ref (match_operand 1 "" "")))])]
  ""
  "")

(define_insn "*jump_indirect"
   [(parallel [
    (set (pc) (match_operand:HI 0 "register_operand" "hxy"))
    (use (label_ref (match_operand 1 "" "")))])]
   ""
  "jp\\t(%0)")

;; indirect jump - let's be conservative!
;; allow only register_operand, even though we could also 
;; allow labels etc.

(define_insn "indirect_jump"
  [(set (pc) (match_operand:HI 0 "register_operand" "=h!xy"))]
  ""
  "jp\\t(%0)")

;;- jump to subroutine

;;when making a call through a function pointer you need to be careful. you put
;; the address in a register and then call happens. We do not have call (iy),so
;; we simulate it to jp (iy). just check it.
 

(define_insn "call"
  [(call (match_operand:QI 0 "general_operand" "mi")
     (match_operand:SI 1 "general_operand" "g"))]
  ""
  "*
  {
		if (GET_CODE( XEXP (operands[0],0)) == REG)
		{
        	operands[2] = gen_label_rtx();
        	operands[3] = gen_label_rtx ();
        	output_asm_insn (\"call\\t%l2\", operands);
        	output_asm_insn (\"jp\\t%l3\", operands);
 		ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (operands[2]));
        output_asm_insn (\"jp\\t(%0)\", operands);
 		ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (operands[3]));
            return \"\";
    	}
		return \"call\\t(%0)\";
	}")


;;- jump to subroutine
(define_insn "call_value"
  [(set (match_operand 0 "" "=g")
    (call (match_operand:QI 1 "general_operand" "mi")
          (match_operand:SI 2 "general_operand" "g")))]
  ""
  "*
  {

	if (GET_CODE (XEXP (operands[1],0)) == REG)
	{
        operands[3] = gen_label_rtx();
        operands[4] = gen_label_rtx ();
        output_asm_insn (\"call\\t%l3\", operands);
        output_asm_insn (\"jp\\t%l4\", operands);
 	ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (operands[3]));
        output_asm_insn (\"jp\\t(%1)\", operands);
 	ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
                                 CODE_LABEL_NUMBER (operands[4]));
            return \"\";
	}
	return \"call\\t(%1)\";
  }")


(define_expand "untyped_call"
  [(parallel [(call (match_operand 0 "" "")
		    (const_int 0))
	      (match_operand 1 "" "")
	      (match_operand 2 "" "")])]
  ""
  "
{
  int i;

  emit_call_insn (gen_call (operands[0], const0_rtx));

  for (i = 0; i < XVECLEN (operands[2], 0); i++)
    {
      rtx set = XVECEXP (operands[2], 0, i);
      emit_move_insn (SET_DEST (set), SET_SRC (set));
    }

  /* The optimizer does not know that the call sets the function value
     registers we stored in the result block.  We avoid problems by
     claiming that all hard registers are used and clobbered at this
     point.  */
  emit_insn (gen_blockage ());

  DONE;
}")

;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and
;; all of memory.  This blocks insns from being moved across this point.

(define_insn "blockage"
  [(unspec_volatile [(const_int 0)] 0)]
  ""
  "")


;;--------------------------------------------------------------------
;;- Prologue and epilogue.
;;--------------------------------------------------------------------
(define_expand "prologue"
  [(const_int 0)]
  ""
  "
{
  expand_prologue (); 
  DONE;
}")

(define_expand "epilogue"
  [(const_int 0)]
  ""
  "
{
  expand_epilogue (); 
  DONE;
}")



(define_expand "return"
  [(return)]
  "reload_completed"
  "
{
  int ret_size = 0;

  if (current_function_return_rtx)
    ret_size = GET_MODE_SIZE (GET_MODE (current_function_return_rtx));
}
")



(define_insn "return_void"
  [(return)]
  "reload_completed"
  "*
{
  rtx next = next_active_insn (insn);

  if (next
      && GET_CODE (next) == JUMP_INSN
      && GET_CODE (PATTERN (next)) == RETURN)
    return \"\";
  if (current_function_interrupt || current_function_trap)
    return \"retn\";
  return \"ret\";
}")
