diff -Naur gcc-2.95.2/config.sub gcc-2.95.2-z80/config.sub
--- gcc-2.95.2/config.sub	Wed Aug  4 13:39:26 1999
+++ gcc-2.95.2-z80/config.sub	Tue Jun  5 13:05:00 2001
@@ -716,6 +716,10 @@
 		basic_machine=i860-stratus
 		os=-sysv4
 		;;
+ 	z80-*)
+        basic_machine=z80-zilog
+        os=-linux
+        ;;
 	sun2)
 		basic_machine=m68000-sun
 		;;
diff -Naur gcc-2.95.2/gcc/config/z80/z80-protos.h gcc-2.95.2-z80/gcc/config/z80/z80-protos.h
--- gcc-2.95.2/gcc/config/z80/z80-protos.h	Thu Jan  1 05:30:00 1970
+++ gcc-2.95.2-z80/gcc/config/z80/z80-protos.h	Tue Jun  5 13:12:00 2001
@@ -0,0 +1,65 @@
+/* Prototypes for exported functions defined in	z80.c 
+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Contributed by Stephane Carrez (stcarrez@worldnet.fr)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+extern int hard_regno_mode_ok PARAMS((int, enum machine_mode));
+
+extern int z80_total_frame_size PARAMS((void));
+
+extern void expand_prologue PARAMS((void));
+extern void expand_epilogue PARAMS((void));
+
+extern void z80_asm_file_start PARAMS((FILE*, char*));
+
+extern rtx z80_compare_op0;
+extern rtx z80_compare_op1;
+extern rtx z80_expand_compare_and_branch PARAMS((enum rtx_code,
+                                                     rtx, rtx, rtx,int));
+extern int z80_go_if_legitimate_address PARAMS((rtx,
+                                                    enum machine_mode,
+                                                    int));
+
+extern void z80_notice_update_cc PARAMS((rtx, rtx));
+
+
+extern void print_operand PARAMS((FILE*,rtx,int));
+extern void print_operand_address PARAMS((FILE*,rtx));
+
+extern int dead_register_here PARAMS((rtx, rtx));
+
+extern void z80_split_move PARAMS((rtx, rtx,rtx));
+extern void z80_split_compare_and_branch PARAMS((enum rtx_code,
+                                                     rtx, rtx, rtx));
+extern rtx z80_gen_lowpart PARAMS((enum machine_mode, rtx));
+extern rtx z80_gen_highpart PARAMS((enum machine_mode, rtx));
+
+extern int z80_small_indexed_indirect_p PARAMS((rtx, enum machine_mode));
+extern int tst_operand PARAMS((rtx,enum machine_mode));
+extern int cmp_operand PARAMS((rtx,enum machine_mode));
+extern int z80_register_indirect_p PARAMS((rtx, enum machine_mode));
+
+extern int symbolic_memory_operand PARAMS((rtx, enum machine_mode));
+
+extern int memory_reload_operand PARAMS((rtx, enum machine_mode));
+extern int stack_register_operand PARAMS((rtx, enum machine_mode));
+extern int non_push_operand PARAMS((rtx, enum machine_mode));
+extern int reg_or_some_mem_operand PARAMS((rtx, enum machine_mode));
+
diff -Naur gcc-2.95.2/gcc/config/z80/z80.c gcc-2.95.2-z80/gcc/config/z80/z80.c
--- gcc-2.95.2/gcc/config/z80/z80.c	Thu Jan  1 05:30:00 1970
+++ gcc-2.95.2-z80/gcc/config/z80/z80.c	Fri Jun 22 11:38:33 2001
@@ -0,0 +1,1560 @@
+/* Subroutines for gcc2 for z80.
+   Copyright (C) 1994, 1995, 1996, 1997, 1999 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 1, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#include "config.h"
+#include <stdio.h>
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "tree.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "insn-flags.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "recog.h"
+#include "z80-protos.h"
+
+
+extern char *version_string;
+
+static rtx find_addr_reg (); 
+rtx ix_reg;
+rtx iy_reg;
+rtx stack_push_word;
+rtx stack_pop_word;
+
+
+/* Set to 1 by expand_prologue() when the function is an interrupt handler.  */
+int current_function_interrupt;
+
+/* Set to 1 by expand_prologue() when the function is a trap handler.  */
+int current_function_trap;
+static int register_indirect_p PARAMS((rtx, enum machine_mode, int));
+static rtx z80_expand_compare PARAMS((enum rtx_code, rtx, rtx));
+static int z80_auto_inc_p PARAMS ((rtx));
+/*These are used to store the compare operands of cmp/tsts for later use in branches. */
+
+rtx z80_compare_op0;
+rtx z80_compare_op1;
+
+long  z80_min_offset = -128;
+
+/* Max offset that is valid for the indirect addressing mode.  */
+long z80_max_offset = 127;
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.
+    - 8 bit values are stored anywhere (except the SP register and IX, IY).
+    - 16 bit values can be stored in any register whose mode is 16
+    - 32 bit values can be stored in hl + de registers or in bc + iy  */
+
+      
+int
+hard_regno_mode_ok (regno, mode)
+     int regno;
+     enum machine_mode mode;
+{
+  switch (GET_MODE_SIZE (mode))
+    {
+
+    case 4:
+	if(mode ==SImode || mode == SFmode)    
+    		 return  HL_REGNO_P (regno) || BC_REGNO_P (regno);
+
+    case 2:
+      return H_REGNO_P (regno);
+
+    case 1:
+      /* Let us not accept IX and IY registers in QI mode. Most of the
+	    instructions does not accept ir registers.  Seems to be okay. */
+
+      return G_REGNO_P (regno) && !SP_REGNO_P (regno) && !A_REGNO_P (regno);
+
+    default:
+      return 0;
+    }
+}
+
+/* This function determines whether op is symbolic memory or not. */
+
+int
+symbolic_memory_operand (op, mode)
+     register rtx op;
+     enum machine_mode mode;
+{
+
+	if (GET_CODE (op) != MEM)
+		return 0;
+	op = XEXP (op,0);
+	switch (GET_CODE (op))
+	{
+    case SYMBOL_REF:
+    case LABEL_REF:
+      return 1;
+    case CONST:
+      op = XEXP (op, 0);
+      return (GET_CODE (XEXP (op, 0)) == SYMBOL_REF
+	      || GET_CODE (XEXP (op, 0)) == LABEL_REF)
+	     && GET_CODE (XEXP (op, 1)) == CONST_INT;
+
+      /* ??? This clause seems to be irrelevant.  */
+    case CONST_DOUBLE:
+      return GET_MODE (op) == mode;
+
+    case PLUS:
+      return symbolic_memory_operand (XEXP (op, 0), mode)
+	&& symbolic_memory_operand (XEXP (op, 1), mode);
+
+    default:
+      return 0;
+    }
+}
+
+int
+reg_or_some_mem_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (GET_CODE (operand) == MEM)
+    {
+      rtx op = XEXP (operand, 0);
+
+      if (symbolic_memory_operand (op, mode))
+	return 1;
+
+      if (IS_STACK_PUSH (operand))
+	return 1;
+
+      if (z80_register_indirect_p (operand, mode))
+	return 1;
+
+      return 0;
+    }
+
+  return register_operand (operand, mode);
+}
+	
+/* Returns 1 if the operand fits in a z80 indirect mode 
+  mem:MODE (REG) or mem: MODE (IX + d)   */
+
+int
+z80_small_indexed_indirect_p (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  rtx base, offset;
+
+  if (GET_CODE (operand) != MEM)
+    return 0;
+
+  operand = XEXP (operand, 0);
+  /* if (REG_P (operand) && (REG_OK_FOR_BASE_P (operand) || HL_REG_P (operand)))
+	   return 1;
+	*/
+
+  if (!register_indirect_p (operand, mode,
+                            (reload_completed | reload_in_progress)))
+    return 0;
+
+  return 1;
+}
+int 
+register_indirect_operand (operand, mode)
+		rtx operand;
+		enum machine_mode mode;
+{
+		return register_indirect_p (operand, mode, 1);
+}
+
+
+
+
+static int
+register_indirect_p (operand, mode, strict)
+     rtx operand;
+     enum machine_mode mode;
+     int strict;
+{
+  rtx base, offset;
+
+  switch (GET_CODE (operand))
+    {
+    case POST_INC:
+    case PRE_INC:
+    case POST_DEC:
+    case PRE_DEC:
+      return 0;
+
+    case PLUS:
+      base = XEXP (operand, 0);
+      if (GET_CODE (base) != REG)
+	return 0;
+
+      offset = XEXP (operand, 1);
+      if ((GET_CODE (offset) != CONST_INT) || !VALID_CONSTANT_OFFSET_P(offset, mode)) 
+	return 0;
+
+	  if (strict == 0)
+	    return 1;
+	 else
+	   return REGNO_OK_FOR_BASE_P2 (REGNO (base), strict);
+      
+    case REG:
+	return REGNO_OK_FOR_BASE_P2 (REGNO (base), strict);
+
+    default:
+      return 0;
+    }
+}
+
+constant_memory_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+{
+  return GET_CODE (op) == MEM && CONSTANT_ADDRESS_P (XEXP (op, 0));
+}
+
+
+int
+z80_register_indirect_p (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (GET_CODE (operand) != MEM)
+    return 0;
+
+  operand = XEXP (operand, 0);
+  return register_indirect_p (operand, mode,
+                              (reload_completed | reload_in_progress));
+}
+
+int
+tst_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (GET_CODE (operand) == MEM)
+    {
+      rtx addr = XEXP (operand, 0);
+      if (z80_auto_inc_p (addr))
+	return 0;
+    }
+  return nonimmediate_operand (operand, mode);
+}
+
+int
+cmp_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (GET_CODE (operand) == MEM)
+    {
+      rtx addr = XEXP (operand, 0);
+      if (z80_auto_inc_p (addr))
+	return 0;
+    }
+  return general_operand (operand, mode);
+}
+
+static int
+go_if_legitimate_address_internal (operand, mode, strict)
+     rtx operand;
+     enum machine_mode mode;
+     int strict;
+{
+  if (CONSTANT_ADDRESS_P (operand))
+    {
+      return 1;
+    }
+  if (register_indirect_p (operand, mode, strict))
+    {
+      return 1;
+    }
+  if (PUSH_POP_ADDRESS_P (operand))
+    {
+      return 1;
+    }
+/*  if (symbolic_memory_operand (operand, mode))
+    {
+      return 1;
+    }
+*/
+  return 0;
+}
+
+int
+z80_go_if_legitimate_address (operand, mode, strict)
+     rtx operand;
+     enum machine_mode mode;
+     int strict;
+{
+  int result;
+
+  result = go_if_legitimate_address_internal (operand, mode, strict);
+
+  return result;
+}
+
+int
+stack_register_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+  return SP_REG_P (operand);
+}
+
+int
+non_stack_register_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+		if (GET_CODE (operand) == REG)
+				return !SP_REG_P (operand);
+		 return general_operand (operand, mode);
+}
+
+
+int
+address_register (rtx op)
+{
+	
+	if (GET_CODE (op) == REG && A_REG_P (op))
+			  return 1;
+	else
+			return 0;
+}
+
+
+int
+memory_reload_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode ATTRIBUTE_UNUSED;
+{
+
+	return GET_CODE (operand) == MEM
+    && GET_CODE (XEXP (operand, 0)) == PLUS
+    && ((GET_CODE (XEXP (XEXP (operand, 0), 0)) == REG
+	 && GET_CODE (XEXP (XEXP (operand, 0), 1)) == CONST_INT)
+	|| (GET_CODE (XEXP (XEXP (operand, 0), 1)) == REG
+	    && GET_CODE (XEXP (XEXP (operand, 0), 0)) == CONST_INT));
+}
+
+/* Split a  SI move into several smaller move operations.
+   The scratch register 'scratch' is used as a temporary to load
+   store intermediate values.  It must be a hard register.  */
+void
+z80_split_move (to, from, scratch)
+     rtx to, from, scratch;
+{
+  rtx low_to, low_from;
+  rtx high_to, high_from;
+  enum machine_mode mode;
+
+  mode = GET_MODE (to);
+  if (GET_MODE_SIZE (mode) == 4)
+    mode = HImode;
+  else
+	abort ();
+
+  low_to = z80_gen_lowpart (mode, to);
+  high_to = z80_gen_highpart (mode, to);
+
+  low_from = z80_gen_lowpart (mode, from);
+  high_from = z80_gen_highpart (mode, from);
+
+  if (H_REG_P (to) || H_REG_P (from))
+    {
+      emit_move_insn (low_to, low_from);
+      emit_move_insn (high_to, high_from);
+    }
+  else
+    {
+      rtx insn;
+
+      emit_move_insn (scratch, low_from);
+      insn = emit_move_insn (low_to, scratch);
+
+      emit_move_insn (scratch, high_from);
+      insn = emit_move_insn (high_to, scratch);
+    }
+}
+int
+non_push_operand (operand, mode)
+     rtx operand;
+     enum machine_mode mode;
+{
+  if (general_operand (operand, mode) == 0)
+    return 0;
+
+  if (push_operand (operand, mode) == 1)
+    return 0;
+  return 1;
+}
+/* Define this macro if references to a symbol must be treated
+   differently depending on something about the variable or function
+   named by the symbol (such as what section it is in).
+
+   For the z80, we want to recognize trap handlers so that we
+   handle calls to traps in a special manner (by issuing the trap).
+   This information is stored in SYMBOL_REF_FLAG.  */
+void
+z80_encode_section_info (decl)
+     tree decl;
+{
+  tree func_attr;
+  int trap_handler;
+  rtx rtl;
+
+  if (TREE_CODE (decl) != FUNCTION_DECL)
+    return;
+
+  rtl = DECL_RTL (decl);
+
+  func_attr = TYPE_ATTRIBUTES (TREE_TYPE (decl));
+  trap_handler = lookup_attribute ("trap", func_attr) != NULL_TREE;
+  SYMBOL_REF_FLAG (XEXP (rtl, 0)) = trap_handler;
+}
+
+
+/* Returns true if X is a PRE/POST increment decrement
+   (same as auto_inc_p() in rtlanal.c but do not take into
+   account the stack).  */
+int
+z80_auto_inc_p (x)
+     rtx x;
+{
+  return GET_CODE (x) == PRE_DEC
+    || GET_CODE (x) == POST_INC
+    || GET_CODE (x) == POST_DEC || GET_CODE (x) == PRE_INC;
+}
+rtx
+z80_gen_lowpart (mode, x)
+     enum machine_mode mode;
+     rtx x;
+{
+  /* We assume that the low part of an auto-inc mode is the same with
+     the mode changed and that the caller split the larger mode in the
+     correct order.  */
+  if (GET_CODE (x) == MEM && z80_auto_inc_p (XEXP (x, 0)))
+    {
+      return gen_rtx (MEM, mode, XEXP (x, 0));
+    }
+
+  /* Note that a CONST_DOUBLE rtx could represent either an integer or a
+     floating-point constant.  A CONST_DOUBLE is used whenever the
+     constant requires more than one word in order to be adequately
+     represented.  */
+  if (GET_CODE (x) == CONST_DOUBLE)
+    {
+      long l[2];
+
+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)
+	{
+	  REAL_VALUE_TYPE r;
+
+	  if (GET_MODE (x) == SFmode)
+	    {
+	      REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+	      REAL_VALUE_TO_TARGET_SINGLE (r, l[0]);
+	    }
+	  else
+	    {
+	      rtx first, second;
+
+	      split_double (x, &first, &second);
+	      return second;
+	    }
+	  if (mode == SImode)
+	    return gen_rtx (CONST_INT, VOIDmode, l[0]);
+
+	  return gen_rtx (CONST_INT, VOIDmode, l[0] & 0x0ffff);
+	}
+      else
+	{
+	  l[0] = CONST_DOUBLE_LOW (x);
+	}
+      if (mode == SImode)
+	return gen_rtx (CONST_INT, VOIDmode, l[0]);
+      else if (mode == HImode && GET_MODE (x) == SFmode)
+	return gen_rtx (CONST_INT, VOIDmode, l[0] & 0x0FFFF);
+      else
+	abort ();
+    }
+
+  if (mode == QImode)  
+  {
+     if(BC_REG_P (x))
+    	return gen_rtx (REG, mode, HARD_C_REGNUM);
+     else if(HL_REG_P (x))
+	     return gen_rtx(REG, mode, HARD_L_REGNUM);
+     else if(DE_REG_P (x))
+	     return gen_rtx(REG, mode, HARD_E_REGNUM);
+	else if (IX_REG_P (x))
+			return gen_rtx_REG (mode, HARD_IXH_REGNUM);
+	else if (IY_REG_P (x))
+			return gen_rtx_REG (mode, HARD_IYH_REGNUM);
+
+  }
+if (mode == HImode)
+{
+	if (HL_REG_P(x))
+		return gen_rtx_REG (HImode, HARD_HL_REGNUM);
+	else if (BC_REG_P (x))
+			return gen_rtx_REG (HImode, HARD_BC_REGNUM);
+
+}
+
+  
+  /* gen_lowpart crashes when it is called with a SUBREG.  */
+  if (GET_CODE (x) == SUBREG && SUBREG_WORD (x) != 0)
+    {
+      if (mode == SImode)
+	return gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_WORD (x) + 2);
+      else if (mode == HImode)
+	return gen_rtx_SUBREG (mode, SUBREG_REG (x), SUBREG_WORD (x) + 1);
+      else
+	abort ();
+    }
+  x = gen_lowpart (mode, x);
+
+  /* Return a different rtx to avoid to share it in several insns
+     (when used by a split pattern).  Sharing addresses within
+     a MEM breaks the Z register replacement (and reloading).  */
+  if (GET_CODE (x) == MEM)
+    x = copy_rtx (x);
+  return x;
+}
+
+rtx
+z80_gen_highpart (mode, x)
+     enum machine_mode mode;
+     rtx x;
+{
+  /* We assume that the high part of an auto-inc mode is the same with
+     the mode changed and that the caller split the larger mode in the
+     correct order.  */
+  if (GET_CODE (x) == MEM && z80_auto_inc_p (XEXP (x, 0)))
+    {
+      return gen_rtx (MEM, mode, XEXP (x, 0));
+    }
+
+  /* Note that a CONST_DOUBLE rtx could represent either an integer or a
+     floating-point constant.  A CONST_DOUBLE is used whenever the
+     constant requires more than one word in order to be adequately
+     represented.  */
+  if (GET_CODE (x) == CONST_DOUBLE)
+    {
+      long l[2];
+
+      if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)
+	{
+	  REAL_VALUE_TYPE r;
+
+	  if (GET_MODE (x) == SFmode)
+	    {
+	      REAL_VALUE_FROM_CONST_DOUBLE (r, x);
+	      REAL_VALUE_TO_TARGET_SINGLE (r, l[1]);
+	    }
+	  else
+	    {
+	      rtx first, second;
+
+	      split_double (x, &first, &second);
+	      return first;
+	    }
+	  if (mode == SImode)
+	    return gen_rtx (CONST_INT, VOIDmode, l[1]);
+
+	  return gen_rtx (CONST_INT, VOIDmode, (l[1] >> 16) & 0x0ffff);
+	}
+      else
+	{
+	  l[1] = CONST_DOUBLE_HIGH (x);
+	}
+
+      if (mode == SImode)
+	return gen_rtx (CONST_INT, VOIDmode, l[1]);
+      else if (mode == HImode && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)
+	return gen_rtx (CONST_INT, VOIDmode, (l[0] >> 16) & 0x0FFFF);
+      else
+	abort ();
+    }
+  if (GET_CODE (x) == CONST_INT)
+    {
+      HOST_WIDE_INT val = INTVAL (x);
+
+      if (mode == QImode)
+	{
+	  return gen_rtx (CONST_INT, VOIDmode, val >> 8);
+	}
+      else if (mode == HImode)
+	{
+	  return gen_rtx (CONST_INT, VOIDmode, val >> 16);
+	}
+    }
+
+  if (mode == QImode)  
+  {
+     if(BC_REG_P (x))
+    	return gen_rtx (REG, mode, HARD_B_REGNUM);
+     else if(HL_REG_P (x))
+	     return gen_rtx(REG, mode, HARD_H_REGNUM);
+     else if(DE_REG_P (x))
+	     return gen_rtx(REG, mode, HARD_D_REGNUM);
+	else if (IX_REG_P (x))
+			return gen_rtx_REG (mode, HARD_IXH_REGNUM);
+	else if (IY_REG_P (x))
+			return gen_rtx_REG (mode, HARD_IYH_REGNUM);
+
+  }
+if (mode == HImode)
+{
+		if (HL_REG_P (x))
+				return gen_rtx_REG (HImode, HARD_DE_REGNUM);
+		else if (BC_REG_P (x))
+				return gen_rtx_REG (HImode, HARD_IY_REGNUM);
+}
+
+  /* gen_highpart crashes when it is called with a SUBREG.  */
+  if (GET_CODE (x) == SUBREG && SUBREG_WORD (x) != 0)
+    {
+      return gen_rtx (SUBREG, mode, XEXP (x, 0), XEXP (x, 1));
+    }
+  x = gen_highpart (mode, x);
+
+  /* Return a different rtx to avoid to share it in several insns
+     (when used by a split pattern).  Sharing addresses within
+     a MEM breaks the Z register replacement (and reloading).  */
+  if (GET_CODE (x) == MEM)
+    x = copy_rtx (x);
+  return x;  
+}
+
+
+static rtx
+z80_expand_compare (code, op0, op1)
+     enum rtx_code code;
+     rtx op0, op1;
+{
+  rtx ret = 0;
+
+  if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)
+    abort ();
+  else
+    {
+      emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,
+			      gen_rtx_COMPARE (VOIDmode, op0, op1)));
+      ret = gen_rtx (code, VOIDmode, cc0_rtx, const0_rtx);
+    }
+
+  return ret;
+}
+
+/* output the compare and branch instructions.We make use of the operands saved 
+ in cmp patterns. For SImode you need to have two compares and branch.
+first you need to compare the lowparts 
+if the condition is eq or ne you can check for the reverse condition 
+and branch. Otherwise compare the highparts and then branch. 
+Check for the proper placement of labels here....
+
+
+Also we do n't have any compare instructions to branch on LE and GT. So when
+the condition code is LE or GT we swap the operands and make the condition code
+swap_conditioncode.
+*/
+
+		
+rtx
+z80_expand_compare_and_branch (code, op0, op1, label,isout)
+     enum rtx_code code;
+     rtx op0, op1, label;  
+     int isout;
+{
+  rtx tmp;
+  enum machine_mode  mode;
+  rtx operands[2];   
+  rtx label1;
+  tmp = op0;
+  if (GET_CODE (op0) == CONST_INT)
+		  tmp = op1;
+
+  switch (GET_MODE (tmp))
+    {
+    case QImode:
+    case HImode:
+	mode = GET_MODE (tmp);
+	if (code == GT || code == LE || code == GTU || code == LEU)
+	{
+			rtx tmp = op0;
+			op0 = op1;
+			op1 = tmp;
+			code = swap_condition (code);
+	}
+   if (GET_CODE (op0) != REG)
+	    op0 = force_reg (mode, op0);
+    if (GET_CODE (op1) != REG)
+	   op1 = force_reg (mode, op1);
+    
+   	if (isout == 1)
+      {
+      tmp = z80_expand_compare (code, op0, op1);
+		debug_rtx (tmp);
+
+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,
+				  gen_rtx_LABEL_REF (VOIDmode, label),
+				  pc_rtx);
+		debug_rtx (tmp);
+       tmp = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));
+
+	  }
+// This case for outputting a comparision of lowpart of a long value.  
+  
+	else if (isout == 0)
+	{
+	 tmp = z80_expand_compare (code, op0, op1);
+ 	  
+	  if (code == EQ || code == NE)
+	 {
+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,
+				  gen_rtx_LABEL_REF (VOIDmode, label),
+				  pc_rtx);
+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));
+	 }
+	}
+// This case for outputting a comparision of high part of a long value.
+	 
+	else if (isout == 2)
+	{
+			//you are braching for a comparision of the high part of an
+			// SImode value.
+	emit_insn (gen_rtx_SET (VOIDmode, op0,  
+	gen_rtx_MINUS (HImode, gen_rtx_MINUS (HImode,
+	gen_rtx_REG (HImode, 14), op0),
+	op1)));
+   
+  tmp  = gen_rtx (code, VOIDmode, cc0_rtx, const0_rtx);
+		
+      tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,
+				  gen_rtx_LABEL_REF (VOIDmode, label),
+				  pc_rtx);
+      emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx, tmp));
+
+   }
+
+      return 0;
+    case SImode:
+      /* Expand SImode branch into multiple compare+branch.  */
+      {
+	rtx lo[2], hi[2], label2;
+	enum rtx_code code1, code2, code3;
+
+	
+	lo[0] = z80_gen_lowpart (HImode, op0);
+	lo[1] = z80_gen_lowpart (HImode, op1);
+	hi[0] = z80_gen_highpart (HImode, op0);
+	hi[1] = z80_gen_highpart (HImode, op1);
+	
+	label2 = gen_label_rtx ();
+	code1 = code;
+	if (code == EQ || code == NE)
+			code1 = reverse_condition (code1);
+
+	z80_expand_compare_and_branch (code1, lo[0], lo[1], label2,0);
+	z80_expand_compare_and_branch (code, hi[0], hi[1], label,2);
+	
+	if (code == EQ || code == NE)
+			emit_label (label2);
+
+
+
+	return 0;
+      }
+
+    default:
+     abort ();
+    }
+  return 0;
+}
+
+
+/* Finds backward in the instructions to see if register 'reg' is
+   dead.  This is used when generating code to see if we can use 'reg'
+   as a scratch register.  This allows us to choose a better generation
+   of code when we know that some register dies or can be clobbered.  */
+
+int
+dead_register_here (x, reg)
+     rtx x;
+     rtx reg;
+{
+  rtx x_reg;
+  rtx p;
+
+  if (HL_REG_P (reg))
+    x_reg = gen_rtx (REG, SImode, HARD_HL_REGNUM);
+  else
+    x_reg = 0;
+
+  for (p = PREV_INSN (x); p && GET_CODE (p) != CODE_LABEL; p = PREV_INSN (p))
+    if (GET_RTX_CLASS (GET_CODE (p)) == 'i')
+      {
+	rtx body;
+
+	body = PATTERN (p);
+
+	if (GET_CODE (body) == CALL_INSN)
+	  break;
+	if (GET_CODE (body) == JUMP_INSN)
+	  break;
+
+	if (GET_CODE (body) == SET)
+	  {
+	    rtx dst = XEXP (body, 0);
+
+	    if (GET_CODE (dst) == REG && REGNO (dst) == REGNO (reg))
+	      break;
+	    if (x_reg && rtx_equal_p (dst, x_reg))
+	      break;
+
+	    if (find_regno_note (p, REG_DEAD, REGNO (reg)))
+	      return 1;
+	  }
+	else if (reg_mentioned_p (reg, p)
+		 || (x_reg && reg_mentioned_p (x_reg, p)))
+	  break;
+      }
+
+  /* Scan forward to see if the register is set in some insns and never
+     used since then. */
+  for (p = x /*NEXT_INSN (x) */ ; p; p = NEXT_INSN (p))
+    {
+      rtx body;
+
+      if (GET_CODE (p) == CODE_LABEL
+	  || GET_CODE (p) == JUMP_INSN
+	  || GET_CODE (p) == CALL_INSN || GET_CODE (p) == BARRIER)
+	break;
+
+      if (GET_CODE (p) != INSN)
+	continue;
+
+      body = PATTERN (p);
+      if (GET_CODE (body) == SET)
+	{
+	  rtx src = XEXP (body, 1);
+	  rtx dst = XEXP (body, 0);
+
+	  if (GET_CODE (dst) == REG
+	      && REGNO (dst) == REGNO (reg) && !reg_mentioned_p (reg, src))
+	    return 1;
+	}
+
+      /* Register is used (may be in source or in dest). */
+      if (reg_mentioned_p (reg, p)
+	  || (x_reg != 0 && GET_MODE (p) == SImode
+	      && reg_mentioned_p (x_reg, p)))
+	break;
+    }
+  return p == 0 ? 1 : 0;
+}
+	
+static rtx
+find_addr_reg (addr)
+     rtx addr;
+{
+  while (GET_CODE (addr) == PLUS)
+    {
+      if (GET_CODE (XEXP (addr, 0)) == REG)
+	addr = XEXP (addr, 0);
+      if (GET_CODE (XEXP (addr, 1)) == REG)
+	addr = XEXP (addr, 1);
+      if (CONSTANT_P (XEXP (addr, 0)))
+	addr = XEXP (addr, 1);
+      if (CONSTANT_P (XEXP (addr, 1)))
+	addr = XEXP (addr, 0);
+    }
+  if (GET_CODE (addr) == REG)
+    return addr;
+  return 0;
+}
+
+
+/* Print the name of register 'regno' in the assembly file.  */
+static void
+asm_print_register (file, regno)
+     FILE *file;
+     int regno;
+{
+  const char *name = reg_names[regno];
+
+  asm_fprintf (file, "%s", name);
+}
+
+/* Returns true if the operand 'op' must be printed with parenthesis
+   arround it.  This must be done only if there is a symbol whose name
+   is a processor register.  */
+static int
+must_parenthesize (op)
+     rtx op;
+{
+  const char *name;
+
+  switch (GET_CODE (op))
+    {
+    case SYMBOL_REF:
+      name = XSTR (op, 0);
+      /* Avoid a conflict between symbol name and a possible
+         register.  */
+      return (strcasecmp (name, "x") == 0
+	      || strcasecmp (name, "y") == 0) ?1:0;
+
+    case PLUS:
+    case MINUS:
+      return must_parenthesize (XEXP (op, 0))
+	|| must_parenthesize (XEXP (op, 1));
+
+    case MEM:
+    case CONST:
+    case ZERO_EXTEND:
+    case SIGN_EXTEND:
+      return must_parenthesize (XEXP (op, 0));
+
+    case CONST_DOUBLE:
+    case CONST_INT:
+    case LABEL_REF:
+    case CODE_LABEL:
+    default:
+      return 0;
+    }
+}
+
+
+/* A C compound statement to output to stdio stream STREAM the
+   assembler syntax for an instruction operand that is a memory
+   reference whose address is ADDR.  ADDR is an RTL expression.  */
+
+void
+print_operand_address (file, addr)
+     FILE *file;
+     rtx addr;
+{
+  rtx base;
+  rtx offset;
+  int need_parenthesis = 0;
+  
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      if (!REG_P (addr))
+	abort ();
+
+      asm_print_register (file, REGNO (addr));
+      //asm_fprintf (file, "+0");
+      break;
+
+    case MEM:
+      base = XEXP (addr, 0);
+      output_addr_const (file, base);
+      break;
+
+    case PLUS:
+      base = XEXP (addr, 0);
+      offset = XEXP (addr, 1);
+      if (!G_REG_P (base) && G_REG_P (offset))
+	{
+	  base = XEXP (addr, 1);
+	  offset = XEXP (addr, 0);
+	}
+      if ((CONSTANT_ADDRESS_P (base)) && (CONSTANT_ADDRESS_P (offset)))
+	{
+	  need_parenthesis = must_parenthesize (addr);
+
+	  output_addr_const (file, base);
+	 if (INTVAL (offset) >=0)   
+	  asm_fprintf (file, "+");       
+	  output_addr_const (file, offset);
+	}
+      else if (REG_P (base)  && REG_OK_FOR_BASE_P (base))
+	{
+	  need_parenthesis = must_parenthesize (addr);
+
+	      asm_print_register (file, REGNO (base));
+	      if (INTVAL(offset) >= 0)   
+	      asm_fprintf (file, "+");
+	      
+	      output_addr_const (file, offset);
+	}
+      else
+	{
+	 abort ();
+	}
+      break;
+
+    default:
+      if (GET_CODE (addr) == CONST_INT
+	  && INTVAL (addr) < 0x8000 && INTVAL (addr) >= -0x8000)
+	{
+	  asm_fprintf (file, "%d", INTVAL (addr));
+	}
+      else
+	{
+	 output_addr_const (file, addr);
+	}
+      break;
+    }
+}
+
+
+
+
+void
+notice_update_cc_on_set(exp, insn)
+  rtx exp;
+  rtx insn;
+{
+    if (GET_CODE (SET_DEST (exp)) == CC0)
+    { 
+	cc_status.flags = 0;					
+	cc_status.value1 = SET_DEST (exp);			
+	cc_status.value2 = SET_SRC (exp);			
+
+/*
+	if (GET_MODE(SET_SRC(exp)) == DFmode)
+	    cc_status.flags |= CC_IN_FPU;
+*/	
+    }							
+    else if ((GET_CODE (SET_DEST (exp)) == REG		
+	      || GET_CODE (SET_DEST (exp)) == MEM)		
+	     && GET_CODE (SET_SRC (exp)) != PC		
+	     && (GET_MODE (SET_DEST(exp)) == HImode		
+		 || GET_MODE (SET_DEST(exp)) == QImode)	
+		&& (GET_CODE (SET_SRC(exp)) == PLUS		
+		    || GET_CODE (SET_SRC(exp)) == MINUS	
+		    || GET_CODE (SET_SRC(exp)) == AND	
+		    || GET_CODE (SET_SRC(exp)) == IOR	
+		    || GET_CODE (SET_SRC(exp)) == XOR	
+		    || GET_CODE (SET_SRC(exp)) == NOT	
+		    || GET_CODE (SET_SRC(exp)) == NEG	
+			|| GET_CODE (SET_SRC(exp)) == REG	
+		    || GET_CODE (SET_SRC(exp)) == MEM))	
+    { 
+	cc_status.flags = 0;					
+	cc_status.value1 = SET_SRC (exp);   			
+	cc_status.value2 = SET_DEST (exp);			
+	
+	if (cc_status.value1 && GET_CODE (cc_status.value1) == REG	
+	    && cc_status.value2					
+	    && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))
+    	    cc_status.value2 = 0;					
+	if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM	
+	    && cc_status.value2					
+	    && GET_CODE (cc_status.value2) == MEM)			
+	    cc_status.value2 = 0; 					
+    }							
+    else if (GET_CODE (SET_SRC (exp)) == CALL)		
+    { 
+	CC_STATUS_INIT; 
+    }
+    else if (GET_CODE (SET_DEST (exp)) == REG)       		
+	/* what's this ? */					
+    { 
+	if ((cc_status.value1					
+	     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1)))
+	    cc_status.value1 = 0;				
+	if ((cc_status.value2					
+	     && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2)))
+	    cc_status.value2 = 0;				
+    }							
+    else if (SET_DEST(exp) == pc_rtx)
+    { 
+	/* jump */
+    }
+    else /* if (GET_CODE (SET_DEST (exp)) == MEM)	*/	
+    {  
+	/* the last else is a bit paranoiac, but since nearly all instructions 
+	   play with condition codes, it's reasonable! */
+
+	CC_STATUS_INIT; /* paranoia*/ 
+    }		        
+}
+
+
+	
+
+int
+dead_p (rtx insn, rtx x)
+{
+  rtx link;
+  unsigned int regno;
+  regno = REGNO (x);
+
+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))
+  {
+      if (REG_NOTE_KIND (link) != REG_DEAD || GET_CODE (XEXP (link, 0)) != 
+REG)
+        continue;
+
+      if (regno == REGNO (XEXP (link, 0)))
+          return 1;
+  }
+  return 0;
+}
+
+
+#define COSTS_N_INSNS(N) ((N) * 4 - 2)
+	
+int
+z80_memory_move_cost (mode, class, in)
+     enum machine_mode mode;
+     enum reg_class class;
+     int in ATTRIBUTE_UNUSED;
+{
+    switch (GET_MODE_SIZE (mode))
+	{
+			case 1:
+					return 4;
+			case 2:
+				return 5;
+			default:
+				return 8;
+	}
+}
+
+
+/* Cost of moving data from a register of class 'from' to on in class 'to'.
+   Reload does not check the constraint of set insns when the two registers
+   have a move cost of 2.  Setting a higher cost will force reload to check
+   the constraints.  */
+int
+z80_register_move_cost (from, to)
+     enum reg_class from;
+     enum reg_class to;
+{
+/*  if (from >= S_REGS && to >= S_REGS)
+    {
+      return COSTS_N_INSNS (3);
+    }
+  if (from <= S_REGS && to <= S_REGS)
+    {
+      return COSTS_N_INSNS (1) + (reload_completed | reload_in_progress);
+    }*/
+		return COSTS_N_INSNS (2);
+
+}
+
+
+/* Provide the costs of an addressing mode that contains ADDR.
+   If ADDR is not a valid address, its cost is irrelevant.  */
+
+int
+z80_address_cost (addr)
+     rtx addr;
+{
+  int cost = 4;
+
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      /* Make the cost of hard registers and specially SP, FP small. */
+      if (REGNO (addr) < FIRST_PSEUDO_REGISTER)
+	cost = 0;
+      else
+	cost = 1;
+      break;
+
+    case SYMBOL_REF:
+      cost = 8;
+      break;
+
+    case LABEL_REF:
+    case CONST:
+      cost = 0;
+      break;
+
+    case PLUS:
+      {
+	register rtx plus0 = XEXP (addr, 0);
+	register rtx plus1 = XEXP (addr, 1);
+
+	if (GET_CODE (plus0) != REG)
+	  break;
+
+	switch (GET_CODE (plus1))
+	  {
+	  case CONST_INT:
+	    if (INTVAL (plus1) >= 2 * z80_max_offset
+		|| INTVAL (plus1) < z80_min_offset)
+	      cost = 3;
+	    else if (INTVAL (plus1) >= z80_max_offset)
+	      cost = 2;
+	    else
+	      cost = 0;
+	    if (REGNO (plus0) < FIRST_PSEUDO_REGISTER)
+	      cost += 0;
+	    else
+	      cost += 1;
+	    break;
+
+	  case SYMBOL_REF:
+	    cost = 8;
+	    break;
+
+	  case CONST:
+	  case LABEL_REF:
+	    cost = 0;
+	    break;
+
+	  default:
+	    break;
+	  }
+	break;
+      }
+    case PRE_DEC:
+    case PRE_INC:
+      if (SP_REG_P (XEXP (addr, 0)))
+	cost = 1;
+      break;
+
+    default:
+      break;
+    }
+  return cost;
+}
+
+void
+z80_asm_file_start (out, main_file)
+     FILE *out;
+     char *main_file;
+{
+  fprintf (out, "/*;;;-----------------------------------------\n");
+  fprintf (out, ";;; Start z80 gcc assembly output\n");
+  fprintf (out, ";;; gcc compiler %s\n", version_string);
+  fprintf (out, ";;;-----------------------------------------\n*/\n");
+  output_file_directive (out, main_file);
+}
+z80_rtx_costs (x, code, outer_code)
+     rtx x;
+     enum rtx_code code, outer_code;
+{
+  enum machine_mode mode = GET_MODE (x);
+  int extra_cost = 0;
+  int total;
+
+  switch (code)
+    {
+    case MEM:
+      return z80_address_cost (XEXP (x, 0)) + 4;
+
+    case ROTATE:
+    case ROTATERT:
+    case ASHIFT:
+    case LSHIFTRT:
+    case ASHIFTRT:
+      if (GET_CODE (XEXP (x, 1)) == CONST_INT)
+	{
+	  int val = INTVAL (XEXP (x, 1));
+	  int cost;
+
+	  /* 8 or 16 shift instructions are fast.
+	     Others are proportional to the shift counter.  */
+	  if (val == 8 || val == 16 || val == -8 || val == -16)
+	    {
+	      val = 0;
+	    }
+	  cost = COSTS_N_INSNS (val + 1);
+	  cost += rtx_cost (XEXP (x, 0), outer_code);
+	  if (GET_MODE_SIZE (mode) >= 4 && val)
+	    {
+	      cost *= 4;
+	    }
+	  return cost;
+	}
+      total = rtx_cost (XEXP (x, 0), outer_code);
+      if (GET_MODE_SIZE (mode) >= 4)
+	{
+	  total += COSTS_N_INSNS (16);
+	}
+      else
+	{
+	  total += COSTS_N_INSNS (8);
+	}
+      return total;
+
+    case MINUS:
+    case PLUS:
+    case AND:
+    case XOR:
+    case IOR:
+      extra_cost = 0;
+
+      total = rtx_cost (XEXP (x, 0), outer_code)
+	+ rtx_cost (XEXP (x, 1), outer_code);
+      if (GET_MODE_SIZE (mode) <= 2)
+	{
+	  total += COSTS_N_INSNS (2);
+	}
+      else
+	{
+	  total += COSTS_N_INSNS (4);
+	}
+      return total;
+
+    case DIV:
+    case MOD:
+      if (mode == QImode || mode == HImode)
+	{
+	  return 30;
+	}
+      else if (mode == SImode)
+	{
+	  return 100;
+	}
+      else
+	{
+	  return 150;
+	}
+
+    case MULT:
+      if (mode == QImode)
+	{
+	  return  2;
+	}
+      if (mode == HImode)
+	{
+	  return  4;
+	}
+      if (mode == SImode)
+	{
+	  return  20;
+	}
+      return 150;
+
+    case NEG:
+    case SIGN_EXTEND:
+      extra_cost = COSTS_N_INSNS (2);
+
+      /* Fall through */
+    case NOT:
+    case COMPARE:
+    case ABS:
+    case ZERO_EXTEND:
+      total = rtx_cost (XEXP (x, 0), outer_code);
+      if (mode == QImode)
+	{
+	  return total + extra_cost + COSTS_N_INSNS (1);
+	}
+      if (mode == HImode)
+	{
+	  return total + extra_cost + COSTS_N_INSNS (2);
+	}
+      if (mode == SImode)
+	{
+	  return total + extra_cost + COSTS_N_INSNS (4);
+	}
+      return total + extra_cost + COSTS_N_INSNS (8);
+
+    case IF_THEN_ELSE:
+      if (GET_CODE (XEXP (x, 1)) == PC || GET_CODE (XEXP (x, 2)) == PC)
+	return COSTS_N_INSNS (1);
+
+      return COSTS_N_INSNS (1);
+
+    default:
+      return COSTS_N_INSNS (4);
+    }
+}         
+
+void
+create_regs_rtx ()
+{
+  /*  regs_inited = 1; */
+  ix_reg = gen_rtx (REG, HImode, HARD_IX_REGNUM);
+  iy_reg = gen_rtx (REG, HImode, HARD_IY_REGNUM);
+
+  stack_push_word = gen_rtx (MEM, HImode, 
+			     gen_rtx (PRE_DEC, HImode,
+				      gen_rtx (REG, HImode, HARD_SP_REGNUM)));
+  stack_pop_word = gen_rtx (MEM, HImode,
+			    gen_rtx (POST_INC, HImode,
+				     gen_rtx (REG, HImode, HARD_SP_REGNUM)));
+
+}
+
+/* Function prologue and epilogue.  */
+
+/* Emit a move after the reload pass has completed.  This is used to
+   emit the prologue and epilogue.  */
+static void
+emit_move_after_reload (to, from, scratch)
+     rtx to, from, scratch;
+{
+  rtx insn;
+
+  if ( H_REG_P (to) || H_REG_P (from))
+    {
+      insn = emit_move_insn (to, from);
+    }
+  else
+    {
+      emit_move_insn (scratch, from);
+      insn = emit_move_insn (to, scratch);
+    }
+
+  /* Put a REG_INC note to tell the flow analysis that the instruction
+     is necessary.  */
+  if (IS_STACK_PUSH (to))
+    {
+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,
+					    XEXP (XEXP (to, 0), 0),
+					    REG_NOTES (insn));
+    }
+  else if (IS_STACK_POP (from))
+    {
+      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,
+					    XEXP (XEXP (from, 0), 0),
+					    REG_NOTES (insn));
+    }
+}
+
+int
+z80_total_frame_size ()
+{
+  int size;
+  int regno;
+
+  size = get_frame_size ();
+  if (frame_pointer_needed)
+    size += HARD_REG_SIZE;
+
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (regs_ever_live[regno] && ! call_used_regs[regno])
+      size += HARD_REG_SIZE;
+
+  return size;
+}
+
+
+void
+expand_prologue ()
+{
+  tree func_attr;
+  int size;
+  int regno;
+  rtx scratch;
+
+  if (reload_completed != 1)
+    abort ();
+
+  size = get_frame_size ();
+
+  create_regs_rtx ();
+
+  /* Generate specific prologue for interrupt handlers.  */
+  func_attr = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));
+  current_function_interrupt = lookup_attribute ("interrupt",
+						 func_attr) != NULL_TREE;
+  current_function_trap = lookup_attribute ("trap", func_attr) != NULL_TREE;
+
+  /* Save current stack frame.  */
+  if (frame_pointer_needed)
+    emit_move_after_reload (stack_push_word,frame_pointer_rtx, scratch);
+
+  /* Create the frame pointer.  */
+  if (frame_pointer_needed){
+		  
+    emit_move_after_reload (frame_pointer_rtx,
+			    const0_rtx, scratch);
+		   emit_insn (gen_rtx_SET (VOIDmode,
+				 frame_pointer_rtx, 
+				 gen_rtx_PLUS (HImode,
+					       frame_pointer_rtx,
+					      stack_pointer_rtx)));  
+
+	}
+   
+  if (size > 0)
+    {
+      rtx insn;
+
+    emit_move_insn (iy_reg, GEN_INT(-size));
+		   emit_insn (gen_rtx_SET (VOIDmode, iy_reg, 
+				 gen_rtx_PLUS (HImode, iy_reg, stack_pointer_rtx)));  
+    emit_move_insn (stack_pointer_rtx, iy_reg);
+	}
+
+
+   	
+	for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+      if (regs_ever_live[regno] && !call_used_regs[regno])
+	{
+	  emit_move_after_reload (stack_push_word,
+				  gen_rtx (REG, HImode, regno), scratch);
+	}
+}
+
+
+
+void
+expand_epilogue ()
+{
+  int size;
+  register int regno;
+  int return_size;
+  rtx scratch;
+
+  if (reload_completed != 1)
+    abort ();
+
+  size = get_frame_size ();
+
+  /* If we are returning a value in two registers, we have to preserve the
+     X register and use the Y register to restore the stack and the saved
+     registers.  Otherwise, use X because it's faster (and smaller).  */
+  if (current_function_return_rtx == 0)
+    return_size = 0;
+  else if (GET_CODE (current_function_return_rtx) == MEM)
+    return_size = HARD_REG_SIZE;
+  else
+    return_size = GET_MODE_SIZE (GET_MODE (current_function_return_rtx));
+
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (regs_ever_live[regno] && ! call_used_regs[regno])
+    {
+	  emit_move_after_reload (gen_rtx (REG, HImode, regno),
+				  stack_pop_word, scratch);
+	}
+
+	 emit_move_insn (stack_pointer_rtx,ix_reg);
+
+
+  /* Restore previous frame pointer.  */
+  if (frame_pointer_needed)
+    emit_move_insn (frame_pointer_rtx, stack_pop_word);
+
+
+  emit_jump_insn (gen_return ());
+}
+
+
+
+
+
diff -Naur gcc-2.95.2/gcc/config/z80/z80.h gcc-2.95.2-z80/gcc/config/z80/z80.h
--- gcc-2.95.2/gcc/config/z80/z80.h	Thu Jan  1 05:30:00 1970
+++ gcc-2.95.2-z80/gcc/config/z80/z80.h	Fri Jun  8 11:29:37 2001
@@ -0,0 +1,1555 @@
+/* Definitions of target machine for GNU compiler.
+   Motorola 68HC11 and 68HC12.
+   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
+   Contributed by Stephane Carrez (stcarrez@worldnet.fr)
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.
+
+*/
+
+#include "elfos.h"
+
+/*****************************************************************************
+**
+** Controlling the Compilation Driver, `gcc'
+**
+*****************************************************************************/
+
+
+/* Names to predefine in the preprocessor for this target machine.  */
+#define CPP_PREDEFINES		"-Dz80"
+
+
+#ifndef IN_LIBGCC2
+#  include <stdio.h>
+#endif
+
+/* Forward type declaration for prototypes definitions.
+   rtx_ptr is equivalent to rtx. Can't use the same name. */
+struct rtx_def;
+typedef struct rtx_def *rtx_ptr;
+
+union tree_node;
+typedef union tree_node *tree_ptr;
+
+/* We can't declare enum machine_mode forward nor include 'machmode.h' here.
+   Prototypes defined here will use an int instead. It's better than no
+   prototype at all. */
+
+typedef int enum_machine_mode;
+
+/*****************************************************************************
+**
+** Run-time Target Specification
+**
+*****************************************************************************/
+
+/* Run-time compilation parameters selecting different hardware subsets.  */
+
+extern int target_flags;
+
+extern short *reg_renumber;	/* def in local_alloc.c */
+
+
+/* Default target_flags if no switches specified.  */
+#define TARGET_SWITCHES {{ "", TARGET_DEFAULT}}
+#ifndef TARGET_DEFAULT
+    #define TARGET_DEFAULT  0
+#endif
+
+
+# define TARGET_Z80 1
+
+
+/* Print subsidiary information on the compiler version in use.  */
+#define TARGET_VERSION		fprintf (stderr, " (z80)")
+
+
+
+/* target machine storage layout */
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+#define BYTES_BIG_ENDIAN 	0	
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields. */
+#define BITS_BIG_ENDIAN        1 
+
+/* Define this if most significant word of a multiword number is numbered.  */
+#define WORDS_BIG_ENDIAN 		0	
+
+/* Number of bits in an addressible storage unit */
+#define BITS_PER_UNIT		8
+
+/* Number of bits in a word */
+#define BITS_PER_WORD		16	
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD		(BITS_PER_WORD/8)
+
+/* Define if you don't want extended real, but do want to use the
+   software floating point emulator for REAL_ARITHMETIC and
+   decimal <-> binary conversion.  */
+#define REAL_ARITHMETIC
+
+/* Width in bits of a pointer.  See also the macro `Pmode' defined below.  */
+#define POINTER_SIZE		16
+
+/* Definition of size_t.  This is really an unsigned short as the
+   z80 only handles a 64K address space.  */
+#define SIZE_TYPE               "short unsigned int"
+
+/* A C expression for a string describing the name of the data type
+   to use for the result of subtracting two pointers.  The typedef
+   name `ptrdiff_t' is defined using the contents of the string.
+   The z80 only has a 64K address space.  */
+#define PTRDIFF_TYPE            "short int"
+
+/* Allocation boundary (bits) for storing pointers in memory.  */
+#define POINTER_BOUNDARY	8
+
+/* Normal alignment required for function parameters on the stack, in bits.
+   This can't be less than BITS_PER_WORD */
+#define PARM_BOUNDARY		(BITS_PER_WORD)
+
+/* Boundary (bits) on which stack pointer should be aligned.  */
+#define STACK_BOUNDARY		8
+
+/* Allocation boundary (bits) for the code of a function.  */
+#define FUNCTION_BOUNDARY	8
+
+/* Biggest alignment that any data type can require on this machine,
+   in bits. */
+#define BIGGEST_ALIGNMENT	8
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY	8
+
+/* Every structure's size must be a multiple of this.  */
+#define STRUCTURE_SIZE_BOUNDARY 8
+
+/* Define this if instructions will fail to work if given data not
+   on the nominal alignment.  If instructions will merely go slower
+   in that case, do not define this macro.  */
+#define STRICT_ALIGNMENT	0
+
+/* An integer expression for the size in bits of the largest integer
+   machine mode that should actually be used.  All integer machine modes of
+   this size or smaller can be used for structures and unions with the
+   appropriate sizes.  */
+#define MAX_FIXED_MODE_SIZE	32	
+
+/* Floats are checked in a generic way. */
+/* #define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) */
+
+
+
+/* target machine storage layout */
+
+/* Size (bits) of the type "int" on target machine
+   (If undefined, default is BITS_PER_WORD).  */
+#define INT_TYPE_SIZE            16
+
+/* Size (bits) of the type "short" on target machine */
+#define SHORT_TYPE_SIZE		16
+
+/* Size (bits) of the type "long" on target machine */
+#define LONG_TYPE_SIZE		32
+
+/* Size (bits) of the type "long long" on target machine */
+#define LONG_LONG_TYPE_SIZE    	32 
+
+/* Size (bits) of the type "char" on target machine */
+#define CHAR_TYPE_SIZE		8
+
+/* A C expression for the size in bits of the type `float' on the
+   target machine. If you don't define this, the default is one word.
+   Don't use default: a word is only 16.  */
+#define FLOAT_TYPE_SIZE         32
+
+/* A C expression for the size in bits of the type double on the target
+   machine. If you don't define this, the default is two words.
+   Be IEEE compliant.  */
+#define DOUBLE_TYPE_SIZE       	32 
+
+#define LONG_DOUBLE_TYPE_SIZE  	32 
+
+/* Define this as 1 if `char' should by default be signed; else as 0.  */
+#define DEFAULT_SIGNED_CHAR	0
+
+#define WCHAR_TYPE              "short int"
+#define WCHAR_TYPE_SIZE         16
+
+/* Define results of standard character escape sequences.  */
+#define TARGET_BELL		007
+#define TARGET_BS		010
+#define TARGET_TAB		011
+#define TARGET_NEWLINE		012
+#define TARGET_VT		013
+#define TARGET_FF		014
+#define TARGET_CR		015
+
+
+/* Standard register usage.  */
+
+#define HARD_REG_SIZE           (UNITS_PER_WORD)
+
+/* Assign names to real z80 registers.
+We allocate hl+de  and bc +iy for 32 bit values.
+Z80 has got register pairs HL(h,l),BC (b,c), DE (d,e),IX (ixh,ixl),IY (iyh,iyl)
+ But we will use hl,bc,de,ix and iy and the single registers become fixed
+registers. 
+(I tried with  individual registers general registers and their pair as
+fixed, but I feel this looks better approach. (???))
+*/
+#define HARD_A_REGNUM		0	
+#define HARD_HL_REGNUM		1	
+#define HARD_DE_REGNUM		2	
+#define HARD_BC_REGNUM		3	
+#define HARD_IY_REGNUM		4	
+#define HARD_IX_REGNUM		5	
+#define HARD_SP_REGNUM		6	
+#define HARD_PC_REGNUM		7	
+#define HARD_H_REGNUM		8	
+#define HARD_L_REGNUM		9
+#define HARD_D_REGNUM		10
+#define HARD_E_REGNUM		11
+#define HARD_B_REGNUM		12
+#define HARD_C_REGNUM		13
+#define HARD_F_REGNUM		14
+#define HARD_IXL_REGNUM		15
+#define HARD_IXH_REGNUM		16
+#define HARD_IYL_REGNUM		17
+#define HARD_IYH_REGNUM		18
+#define HARD_N_REGS		19	
+
+#define PC_REGNUM		10	
+
+
+/* Number of actual hardware registers. The hardware registers are assigned
+   numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. 
+   All registers that the compiler knows about must be given numbers, even
+   those that are not normally considered general registers. */
+#define FIRST_PSEUDO_REGISTER		HARD_N_REGS
+
+/* 1 for registers that have pervasive standard uses and are not available
+   for the register allocator. */
+#define FIXED_REGISTERS \
+  {0,  0,  0, 0,  0,  0,  1,  1,  1, 1,  1, 1, 1, 1, 1, 1,  1, 1, 1 }
+/* A, HL, DE, BC, IY, IX, SP, PC, H, L,  B, C, D, E, F, IXL,IXH,IYH,IYL */
+
+
+/* 1 for registers not available across function calls. For our pseudo
+   registers, all are available.  */
+#define CALL_USED_REGISTERS \
+  {1,  1,  1, 1,  1,  1,  1,  1,  1, 1,  1, 1, 1, 1, 1, 1,  1, 1, 1 }
+/* A, HL, DE, BC, IY, IX, SP, PC, H, L,  B, C, D, E, F, IXL,IXH,IYH,IYL */
+
+
+/* Define this macro to change register usage conditional on target flags.
+#define CONDITIONAL_REGISTER_USAGE (z80_conditional_register_usage ())
+*/
+
+/* List the order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS.  */
+#define REG_ALLOC_ORDER						\
+{ HARD_A_REGNUM,HARD_HL_REGNUM,HARD_BC_REGNUM,HARD_DE_REGNUM,			\
+  HARD_IY_REGNUM,HARD_IX_REGNUM,	HARD_SP_REGNUM,\
+  HARD_PC_REGNUM,HARD_H_REGNUM,HARD_L_REGNUM, HARD_B_REGNUM,\
+  HARD_C_REGNUM,HARD_D_REGNUM,HARD_E_REGNUM,HARD_F_REGNUM,HARD_IXL_REGNUM,\
+  HARD_IXH_REGNUM,HARD_IYL_REGNUM,HARD_IYH_REGNUM,			\
+}
+
+/* A C expression for the number of consecutive hard registers,
+   starting at register number REGNO, required to hold a value of
+   mode MODE.  */
+#define HARD_REGNO_NREGS(REGNO, MODE) \
+((Q_REGNO_P (REGNO)) ? (GET_MODE_SIZE (MODE)) : \
+   ((GET_MODE_SIZE (MODE) + HARD_REG_SIZE - 1) / HARD_REG_SIZE))
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.
+    - 8 bit values are stored anywhere (except the IX,IY and SP register).
+    - 16 bit values can be stored in  all long registers.
+    - 32 bit values can be stored in  (hl + de) or (bc + iy) registers 
+   lowpart will be hl and high part is de.
+   (you have instruction ex hl, de (1 byte).A bit cheaper than (hl + bc).
+ */
+
+#define HARD_REGNO_MODE_OK(REGNO, MODE) \
+     hard_regno_mode_ok (REGNO,MODE)
+
+/* Value is 1 if it is a good idea to tie two pseudo registers when one has
+   mode MODE1 and one has mode MODE2.  If HARD_REGNO_MODE_OK could produce
+   different values for MODE1 and MODE2, for any hard reg, then this must be
+   0 for correct output.  */
+#define MODES_TIEABLE_P(MODE1, MODE2)                   \
+     (((MODE1) == (MODE2))                              \
+      || ((MODE1) == SImode && (MODE2) == HImode)	\
+      || ((MODE1) == HImode && (MODE2) == SImode))
+
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.  
+ 
+  On z80 we have register pairs.
+  h+l, d+e, b+c
+  ixh+ixl, iyh+iyl.
+  We use hl,de, bc, ix and iy registers .We do not use the registers 
+  individually . I had problems for reloads of SImode values, 
+  when used registers individually. So I moved on to this approach.
+  
+  QImode values can be stored in hl,de,bc and a registers.
+  HImode values can be stored in HL, DE,BC,IY,IX or SP  registers.
+  For this we have  register classes HL_REGS, DE_REGS and BC_REGS.
+  SImode velues are stored in  hl + de and bc +iy registers.
+  For this we have classes HL_OR_DE_REGS and BC_OR_IY_REGS.
+  */
+
+enum reg_class
+{	NO_REGS,	/* no registers class , gcc insists on this	*/
+	DA_REGS,	/* register a					*/
+	HL_REGS,	/* 16 bit accumulator  				*/
+	DE_REGS,	/*  DE			*/
+	BC_REGS,	/*  BC  				*/
+	IY_REGS,	/*  IY register 						*/
+	IX_REGS,	/*  IX  register 						*/
+	HL_OR_DE_REGS,	/* HL or DE register				*/
+	BC_OR_IY_REGS,	/* BC or IY register 						*/
+	A_REGS,		/* address registers IX, IY			*/
+	RR_REGS,	/* registers HL,IX or IY			*/
+	SP_REGS,	/* register SP					*/
+	SS_REGS,	/* registers BC,DE,HL,SP			*/
+	Q_REGS,		/* register A,B,C,D,E,H,L, ixh,ixl, iyh,iyl  	*/
+	H_REGS,		/* BC,DE,HL,IX,IY,SP 				*/
+	G_REGS,		/* all registers				*/
+	ALL_REGS,
+	LIM_REG_CLASSES
+};
+
+#define GENERAL_REGS    G_REGS		/* alias GENERAL_REGS to G_REGS.*/
+#define N_REG_CLASSES (int)LIM_REG_CLASSES
+#define REG_CLASS_NAMES \
+{	"NO_REGS",	\
+	"DA_REGS",	\
+	"HL_REGS",	\
+	"DE_REGS",	\
+	"BC_REGS",	\
+	"IY_REGS",	\
+	"IX_REGS",	\
+	"HL_OR_DE_REGS",	\
+	"BC_OR_IY_REGS",	\
+	"A_REGS",	\
+	"RR_REGS",	\
+	"SP_REGS",	\
+	"SS_REGS",	\
+	"Q_REGS",	\
+	"H_REGS",	\
+	"G_REGS",	\
+	"ALL_REGS" }
+
+
+/* An initializer containing the contents of the register classes,
+   as integers which are bit masks.  The Nth integer specifies the
+   contents of class N.  The way the integer MASK is interpreted is
+   that register R is in the class if `MASK & (1 << R)' is 1.  */
+
+/*--------------------------------------------------------------
+   A		0x00000001
+   HL		0x00000002
+   DE		0x00000004
+   BC		0x00000008
+   IY		0x00000010
+   IX		0x00000020
+   SP		0x00000040
+   PC		0x00000080
+   H		0x00000100
+   L		0x00000200
+   D       	0x00000400
+   E		0x00000800
+   B		0x00001000
+   C		0x00002000
+   F        0x00004000
+   IXL		0x00008000	
+   IXH      0x00010000
+   IYL      0x00020000
+   IYH      0x00040000 
+
+   HL_REGS represents HL. It is used for 16-bits numbers.
+   DE_REGS represents DE. It is used for 16-bits numbers.
+   BC_REGS represents BC. It is used for 16-bits numbers.
+   A_REGS      represents a valid base register for indexing. It represents
+	       X,Y.
+   HL_OR_DE_REGS represents HL + DE. It is used for 32-bits numbers.
+   BC_OR_IY_REGS represents BC + IY. It is used for 32-bits numbers.
+--------------------------------------------------------------*/
+
+#define REG_CLASS_CONTENTS					  \
+/* NO_REGS	*/		   {{ 0x00000000},				  \
+/* DA_REGS	*/ 		 	{ 0x00000001}, /* A				*/\
+/* HL_REGS	*/ 		{ 0x00000002}, /* HL				*/\
+/* DE_REGS	*/ 		{ 0x00000004}, /* DE 				*/\
+/* BC_REGS	*/ 		{ 0x00000008}, /* BC				*/\
+/* IY_REGS	*/ 			{ 0x00000010}, /* IY			*/\
+/* IX_REGS*/ 			{ 0x00000020}, /* IX 				*/\
+/* HL_OR_DE_REGS*/ 		{ 0x00000006},  /* HL,DE 				*/\
+/* BC_OR_IY_REGS*/ 		{ 0x00000018}, 	/* BC,IY 				*/\
+/* A_REGS*/ 			{ 0x00000030},  /* IX,IY 				*/\
+/* RR_REGS	*/ 			{ 0x00000032},	/* HL,IX,IY 			*/\
+/* SP_REGS	*/ 			{ 0x00000040}, 	/* SP				*/\
+/* SS_REGS	*/ 			{ 0x0000004E}, /*HL,BC,DE,SP */\
+/* Q_REGS	*/ 			{ 0x0007BF00}, /* A,B,C,D,E,H,LIXH,IXL,IYH,IYL	*/\
+/* H_REGS	*/ 			{ 0x0000007E}, /* HL,BC,DE,SP, IX OR IY	*/\
+/* G_REGS	*/ 			{ 0x0007FFFF}, /*            		*/\
+/* ALL_REGS	*/ 			{ 0x0007FFFF}}
+
+
+
+
+#define Q_REGNO_P(REGNO)	((REGNO) == HARD_A_REGNUM	\
+                                 ||(REGNO) == HARD_B_REGNUM	\
+                                 ||(REGNO) == HARD_C_REGNUM	\
+                                 ||(REGNO) == HARD_D_REGNUM	\
+                                 ||(REGNO) == HARD_E_REGNUM	\
+                                 ||(REGNO) == HARD_H_REGNUM	\
+                                 ||(REGNO) == HARD_L_REGNUM \
+                                 ||(REGNO) == HARD_IXH_REGNUM	\
+                                 ||(REGNO) == HARD_IXL_REGNUM	\
+                                 ||(REGNO) == HARD_IYH_REGNUM	\
+                                 ||(REGNO) == HARD_IYL_REGNUM)
+
+
+#define Q_REG_P(X)		(REG_P (X) && Q_REGNO_P (REGNO (X)))
+
+/* HL registers */
+
+#define HL_REGNO_P(REGNO)	((REGNO) == HARD_HL_REGNUM)
+#define HL_REG_P(X)		(REG_P (X) && HL_REGNO_P (REGNO (X)))
+
+#define HL_OR_DE_REG_P(X)		(REG_P (X) && HL_OR_DE_REGNO_P (REGNO (X)))
+
+#define HL_OR_DE_REGNO_P(REGNO)	(HL_REGNO_P(REGNO)	\
+								||	DE_REGNO_P(REGNO))
+
+#define BC_OR_IY_REG_P(X)		(REG_P (X) && BC_OR_IY_REGNO_P (REGNO (X)))
+#define BC_OR_IY_REGNO_P(REGNO)	(BC_REGNO_P(REGNO)	\
+								||	IY_REGNO_P(REGNO))
+
+/* BC registers */
+
+#define BC_REGNO_P(REGNO)	((REGNO) == HARD_BC_REGNUM)
+#define BC_REG_P(X)		(REG_P (X) && BC_REGNO_P (REGNO (X)))
+
+/* D OR E registers */
+
+#define DE_REGNO_P(REGNO)	((REGNO) == HARD_DE_REGNUM)
+#define DE_REG_P(X)		(REG_P (X) && DE_REGNO_P (REGNO (X)))
+
+/* IX OR IY registers */
+
+#define IX_REGNO_P(REGNO)	((REGNO) == HARD_IX_REGNUM)
+#define IX_REG_P(X)		(REG_P (X) && IX_REGNO_P (REGNO (X)))
+
+#define IY_REGNO_P(REGNO)	((REGNO) == HARD_IY_REGNUM)
+#define IY_REG_P(X)		(REG_P (X) && IY_REGNO_P (REGNO (X)))
+
+#define A_REGNO_P(REGNO)        ((REGNO) == HARD_IX_REGNUM 		\
+                                || (REGNO) == HARD_IY_REGNUM)
+#define A_REG_P(X)              (REG_P (X) && A_REGNO_P (REGNO (X)))
+
+
+
+#define DA_REGNO_P(REGNO)	((REGNO) == HARD_A_REGNUM)
+#define DA_REG_P(X)		(REG_P (X) && DA_REGNO_P (REGNO (X)))
+
+
+#define SP_REGNO_P(REGNO)       ((REGNO) == HARD_SP_REGNUM)
+#define SP_REG_P(X)             (REG_P (X) && SP_REGNO_P (REGNO (X)))
+
+
+/* ALL z80 long registers  BC,DE, HL, IX,IY and SP  */
+
+#define H_REGNO_P(REGNO)		(HL_REGNO_P (REGNO) \
+								|| A_REGNO_P (REGNO) \
+								|| BC_REGNO_P (REGNO) \
+								|| DE_REGNO_P (REGNO)\
+							|| SP_REGNO_P (REGNO))
+#define H_REG_P(X)              (REG_P (X) && H_REGNO_P (REGNO (X)))
+
+#define G_REGNO_P(REGNO)	(H_REGNO_P (REGNO)	|| SP_REGNO_P (REGNO)\
+								|| Q_REGNO_P (REGNO) \
+								||((REGNO) == HARD_PC_REGNUM))
+#define G_REG_P(X)              (REG_P (X) && G_REGNO_P (REGNO (X)))
+
+
+#define REGNO_REG_CLASS(REGNO) \
+  (DA_REGNO_P (REGNO) ? DA_REGS : \
+   (HL_REGNO_P (REGNO) ? HL_REGS : \
+   (DE_REGNO_P (REGNO) ? DE_REGS : \
+   (BC_REGNO_P (REGNO) ? BC_REGS : \
+   (IY_REGNO_P (REGNO) ? IY_REGS : \
+   (IX_REGNO_P (REGNO) ? IX_REGS : \
+   (HL_OR_DE_REGNO_P (REGNO) ? HL_OR_DE_REGS : \
+   (BC_OR_IY_REGNO_P (REGNO) ? BC_OR_IY_REGS : \
+     (SP_REGNO_P (REGNO) ? SP_REGS : \
+      (H_REGNO_P (REGNO) ? H_REGS : \
+        (G_REGNO_P (REGNO) ? G_REGS : ALL_REGS)))))))))))  
+
+
+/* Get reg_class from a letter in the machine description.  */
+
+#define REG_CLASS_FROM_LETTER(C) \
+   ((C) == 'a' ? DA_REGS : \
+    (C) == 'A' ? A_REGS : \
+    (C) == 'h' ? HL_REGS : \
+    (C) == 'b' ? BC_REGS : \
+    (C) == 'd' ? DE_REGS : \
+    (C) == 'D' ? HL_OR_DE_REGS : \
+    (C) == 'u' ? BC_OR_IY_REGS : \
+    (C) == 'q' ? Q_REGS : \
+    (C) == 'z' ? RR_REGS : \
+    (C) == 't' ? H_REGS : \
+    (C) == 'w' ? SP_REGS : \
+    (C) == 'x' ? IX_REGS : \
+    (C) == 'y' ? IY_REGS : NO_REGS)
+
+
+#define PREFERRED_RELOAD_CLASS(X,CLASS)		(CLASS)
+
+#define SECONDARY_ELOAD_CLASS(CLASS,MODE,IN) \
+	(((CLASS) != DA_REGS && MODE == QImode && \
+ 	 symbolic_memory_operand (X, MODE))\
+	 ? DA_REGS: NO_REGS)
+
+
+
+#define SMALL_REGISTER_CLASSES 1
+
+/* A C expression whose value is nonzero if pseudos that have been
+   assigned to registers of class CLASS would likely be spilled
+   because registers of CLASS are needed for spill registers.
+
+   The default value of this macro returns 1 if CLASS has exactly one
+   register and zero otherwise.  On most machines, this default
+   should be used.  Only define this macro to some other expression
+   if pseudo allocated by `local-alloc.c' end up in memory because
+   their hard registers were needed for spill registers.  If this
+   macro returns nonzero for those classes, those pseudos will only
+   be allocated by `global.c', which knows how to reallocate the
+   pseudo to another register.  If there would not be another
+   register available for reallocation, you should not change the
+   definition of this macro since the only effect of such a
+   definition would be to slow down register allocation.  */
+
+#define CLASS_LIKELY_SPILLED_P(CLASS)					\
+  (((CLASS) == DA_REGS)							\
+   || ((CLASS) == HL_REGS)                                               \
+   || ((CLASS) == BC_REGS)                                               \
+   || ((CLASS) == DE_REGS)                                               \
+   || ((CLASS) == A_REGS)                                               \
+   || ((CLASS) == SP_REGS)                                              \
+   || ((CLASS) == HL_OR_DE_REGS)                                          \
+   || ((CLASS) == BC_OR_IY_REGS)                                          \
+   || ((CLASS) == IX_REGS)                                         \
+   || ((CLASS) == IY_REGS))
+
+/* Return the maximum number of consecutive registers needed to represent
+   mode MODE in a register of class CLASS.  
+   Verify this macro......
+ 
+|| (CLASS) == BC_OR_IY_REGS) ? GET_MODE_SIZE (MODE) \
+ */
+
+#define CLASS_MAX_NREGS(CLASS, MODE)				\
+( ((CLASS) == DA_REGS || (CLASS) == Q_REGS)?			\
+  GET_MODE_SIZE (MODE):						\
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))
+
+/* The letters I, J, K, L and M in a register constraint string
+   can be used to stand for particular ranges of immediate operands.
+   This macro defines what the ranges are.
+   C is the letter, and VALUE is a constant value.
+   Return 1 if VALUE is in the range specified by C.
+
+   `L' is for range -65536 to 65536
+   `M' is for values whose 16-bit low part is 0
+   'N' is for +1 or -1.
+   'O' is for 16 (for rotate using swap).
+   'P' is for range -8 to 2 (used by addhi_sp)
+
+   'I', 'J', 'K' are not used.  */
+
+#define CONST_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'L' ? (VALUE) >= -65536 && (VALUE) <= 65535 : \
+   (C) == 'M' ? ((VALUE) & 0x0ffffL) == 0 : \
+   (C) == 'N' ? ((VALUE) == 1 || (VALUE) == -1):0)
+
+/* Similar, but for floating constants, and defining letters G and H.
+   No floating-point constants are valid on 68HC11.  */
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0
+
+/* 'U' represents certain kind of memory indexed operand for z80.
+  'R' is actually for symbolic memory.
+ */
+
+#define EXTRA_CONSTRAINT(OP, C) \
+	((C)=='U' ? z80_small_indexed_indirect_p(OP,GET_MODE(OP)):\
+	 (C)=='R' ? (GET_CODE (OP) == MEM && !z80_small_indexed_indirect_p(OP,GET_MODE(OP))):0)
+
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+#define STACK_GROWS_DOWNWARD
+
+/* Define this if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.   */
+
+#define FRAME_GROWS_DOWNWARD
+
+/* Define this if successive arguments to a function occupy decreasing 
+   addresses in the stack.  */
+/* #define ARGS_GROW_DOWNWARD */
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+#define STARTING_FRAME_OFFSET		0  	
+
+/* Offset of first parameter from the argument pointer register value.  */
+
+#define FIRST_PARM_OFFSET(FNDECL)	4	
+
+/* A C expression whose value is RTL representing the location of the
+   incoming return address at the beginning of any function, before the
+   prologue.  This RTL is either a REG, indicating that the return
+   value is saved in REG, or a MEM representing a location in
+   the stack.
+  
+   Before the prologue, RA is at 0(sp). */
+#define INCOMING_RETURN_ADDR_RTX \
+    gen_rtx_MEM (VOIDmode, gen_rtx_REG (VOIDmode, STACK_POINTER_REGNUM))
+
+/* Before the prologue, the top of the frame is at 2(sp).  */
+#define INCOMING_FRAME_SP_OFFSET        2
+
+/* Define this if functions should assume that stack space has been
+   allocated for arguments even when their values are passed in
+   registers.
+  
+   The value of this macro is the size, in bytes, of the area reserved for
+   arguments passed in registers.
+  
+   This space can either be allocated by the caller or be a part of the
+   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'
+   says which. */
+/* #define REG_PARM_STACK_SPACE(FNDECL)	2 */
+
+/* Define this macro if REG_PARM_STACK_SPACE is defined but stack
+   parameters don't skip the area specified by REG_PARM_STACK_SPACE.
+   Normally, when a parameter is not passed in registers, it is placed on
+   the stack beyond the REG_PARM_STACK_SPACE area.  Defining this macro  
+   suppresses this behavior and causes the parameter to be passed on the
+   stack in its natural location.  */
+/* #define STACK_PARMS_IN_REG_PARM_AREA */
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM		HARD_SP_REGNUM
+
+/* Base register for access to local variables of the function.  */
+#define FRAME_POINTER_REGNUM		HARD_IX_REGNUM
+
+/* Base register for access to arguments of the function.  */
+#define ARG_POINTER_REGNUM			FRAME_POINTER_REGNUM
+
+/* Register in which static-chain is passed to a function. 
+  This needs to be looked in more closely. I am saing the static chain
+  should be passed in iy register.
+   But actually I am modifying this register in the prologue ??
+   To allocate frame --- ld iy, frame_size
+   						  add iy, sp
+						  ld sp, iy
+  This is the combination that I could find for frame setup.
+
+ May be we can pass this in memory. (??)
+ --need to look in to this.
+
+
+ */
+#define STATIC_CHAIN_REGNUM	  		HARD_IY_REGNUM  
+
+
+
+/* Value should be nonzero if functions must have frame pointers.
+   Zero means the frame pointer need not be set up (and parms may be
+   accessed via the stack pointer) in functions that seem suitable.
+   This is computed in `reload', in reload1.c. */
+#define FRAME_POINTER_REQUIRED	0
+
+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH_VAR)			\
+{                                                               \
+  int offset, regno;                                            \
+  offset = get_frame_size();                                    \
+  for (regno = 0; regno < 8; regno++)                           \
+    if (regs_ever_live[regno] && ! call_used_regs[regno])       \
+      offset += 2;                                              \
+  (DEPTH_VAR) = offset;                                         \
+}
+
+/* LONGJMP_RESTORE_FROM_STACK */
+
+
+/* Passing Function Arguments on the Stack.  */
+
+/* When a prototype says `char' or `short', really pass an `int'.  
+   A guess for z80. We do n't have instructions to push a single
+   byte on to stack */
+
+
+#define PROMOTE_PROTOTYPES 
+
+/* If we generate an insn to push BYTES bytes, this says how many the
+   stack pointer really advances by. When ever we push it is interms of word.
+*/
+
+#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & (-2))
+
+/* Value is 1 if returning from a function call automatically pops the
+   arguments described by the number-of-args field in the call. FUNTYPE is
+   the data type of the function (as a tree), or for a library call it is
+   an identifier node for the subroutine name.  */
+
+  
+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)	0
+
+/* Nonzero if type TYPE should be returned in memory.
+   Blocks and data types largers than 4 bytes cannot be returned
+   in the register (hl + de = 4).  */
+#define RETURN_IN_MEMORY(TYPE)				\
+    ((TYPE_MODE (TYPE) == BLKmode)			\
+     ? (int_size_in_bytes (TYPE) > 4)			\
+     : (GET_MODE_SIZE (TYPE_MODE (TYPE)) > 4))
+
+
+/* Passing Arguments in Registers.  */
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+
+#define CUMULATIVE_ARGS	int
+
+/* A C expression that indicates when an argument must be passed by reference.
+   If nonzero for an argument, a copy of that argument is made in memory and a
+   pointer to the argument is passed instead of the argument itself.
+   The pointer is passed in whatever way is appropriate for passing a pointer
+   to that type.  */
+
+ 
+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)		\
+  ((TYPE) && int_size_in_bytes (TYPE) > 8)
+
+
+/* If defined, a C expression which determines whether, and in which direction,
+   to pad out an argument with extra space.  The value should be of type
+   `enum direction': either `upward' to pad above the argument,
+   `downward' to pad below, or `none' to inhibit padding.
+
+   Structures are stored left shifted in their argument slot.  
+  The default definition should suffice.
+ */
+
+/* #define FUNCTION_ARG_PADDING(MODE, TYPE)  */
+
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a
+   function whose data type is FNTYPE. For a library call, FNTYPE is 0. */
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)	\
+ ((CUM)= 0)
+
+/* Update the data in CUM to advance over an argument of mode MODE and data
+   type TYPE. (TYPE is null for libcalls where that information may not be
+   available.) 
+  This does not matter if all the arguments are passed on stack.
+ */
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED) \
+ ((CUM) += (GET_MODE_SIZE (MODE) + 1) & (-2)) 
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+    (otherwise it is an extra parameter matching an ellipsis).  
+
+  As a first hand approach let me push all the arguments on to stack.
+  May be in the next round I can pass them in registers. 
+ */
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)	0
+
+
+/* Define the profitability of saving registers around calls.
+
+   Disable this because the saving instructions generated by
+   caller-save need a reload and the way it is implemented,
+   it forbids all spill registers at that point.  Enabling
+   caller saving results in spill failure.  
+#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0
+*/
+#define DEFAULT_CALLER_SAVES
+
+/* For an arg passed partly in registers and partly in memory,
+   this is the number of registers used.
+   For args passed entirely in registers or entirely in memory, zero.
+
+   Passing an arg partly in register and memory does not work at all.
+   Don't do that.  */
+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) (0)
+
+/* 1 if N is a possible register number for function argument passing.
+   HL is for 16-bit values, HL + DE is for 32-bit  */
+#define FUNCTION_ARG_REGNO_P(N)	(0)
+
+/* All return values are in the D or X+D registers:
+    - 8 and 16-bit values are returned in hl.
+      BLKmode are passed in HL as pointer.
+    - 32-bit values are returned in hl + de. 
+      The high part is passed in de and the low part in hl. */
+
+#define FUNCTION_VALUE(VALTYPE, FUNC)					\
+     gen_rtx (REG, TYPE_MODE (VALTYPE),					\
+		    HARD_HL_REGNUM)
+
+#define LIBCALL_VALUE(MODE)						\
+     gen_rtx (REG, MODE,HARD_HL_REGNUM)
+
+/* 1 if N is a possible register number for a function value.  */
+#define FUNCTION_VALUE_REGNO_P(N) \
+     ((N) == HARD_HL_REGNUM)
+
+/* Register in which address to store a structure value is passed to a
+   function.  */
+#define STRUCT_VALUE_REGNUM		0
+
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in functions
+   that have frame pointers. No definition is equivalent to always zero.  */
+#define EXIT_IGNORE_STACK	0
+
+
+/* Generating Code for Profiling.  */
+
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+#define FUNCTION_PROFILER(FILE, LABELNO)	;
+
+/* Save all registers which may be clobbered by a function call.
+   MACHINE_STATE_SAVE and MACHINE_STATE_RESTORE are target-code macros,
+   used in libgcc2.c.  They may not refer to TARGET_* macros !!!
+
+   We don't need to save the CCR nor the soft registers because
+   they will be saved by gcc.  */
+#define MACHINE_STATE_SAVE(id) \
+  {			       \
+    asm ("push\thl");	       \
+    asm ("push\tde");	       \
+    asm ("push\tbc");	       \
+    asm ("push\tix");	       \
+    asm ("push\tiy");	       \
+  }
+
+#define MACHINE_STATE_RESTORE(id) \
+  {			       \
+    asm ("pop\tiy");	       \
+    asm ("pop\tix");	       \
+    asm ("pop\tbc");	       \
+    asm ("pop\tde");	       \
+    asm ("pop\thl");	       \
+  }
+
+/* Output assembler code for a block containing the constant parts
+   of a trampoline, leaving space for the variable parts.  */
+#define TRAMPOLINE_TEMPLATE(FILE) { \
+  fprintf (FILE, "\t.bogus\t\t; TRAMPOLINE_TEMPLATE unimplemented\n"); }
+
+/* Length in units of the trampoline for entering a nested function.  */
+#define TRAMPOLINE_SIZE		0
+
+/* A C statement to initialize the variable parts of a trampoline.
+   ADDR is an RTX for the address of the trampoline; FNADDR is an
+   RTX for the address of the nested function; STATIC_CHAIN is an
+   RTX for the static chain value that should be passed to the
+   function when it is called.  */
+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) { \
+	}
+
+
+
+/* `INIT_TARGET_OPTABS'
+     Define this macro as a C statement that declares additional library
+     routines renames existing ones. `init_optabs' calls this macro
+     after initializing all the normal library routines.
+*/
+
+#define MODHI3_LIBCALL "__modhi3"
+#define DIVHI3_LIBCALL "__divhi3"
+#define MULHI3_LIBCALL "__mulhi3"
+/*
+#define MODQI3_LIBCALL "__modqi3"
+#define DIVQI3_LIBCALL "__divqi3"
+#define MULQI3_LIBCALL "__mulqi3"
+*/
+
+#define INIT_TARGET_OPTABS \
+  do { \
+    smod_optab->handlers[(int) HImode].libfunc		\
+      = gen_rtx (SYMBOL_REF, Pmode, MODHI3_LIBCALL);	\
+    sdiv_optab->handlers[(int) HImode].libfunc		\
+      = gen_rtx (SYMBOL_REF, Pmode, DIVHI3_LIBCALL);	\
+    smul_optab->handlers[(int) HImode].libfunc				\
+      = gen_rtx_SYMBOL_REF (Pmode, MULHI3_LIBCALL);			\
+  } while (0)
+
+
+/* Addressing modes, and classification of registers for them.  */
+/*
+#define HAVE_POST_INCREMENT 
+#define HAVE_PRE_INCREMENT 
+#define HAVE_POST_DECREMENT 
+#define HAVE_PRE_DECREMENT 
+*/
+
+/* The class value for base registers. For z80 we define it as A_REGS (IX or IY)
+  registers */
+#define BASE_REG_CLASS		A_REGS
+
+
+/* The class value for index registers.  This is NO_REGS for z80.  */
+
+#define INDEX_REG_CLASS		NO_REGS
+
+#define REG_VALID_FOR_BASE_P(REGNO)             \
+     ((REGNO) < FIRST_PSEUDO_REGISTER               \
+          && ( (REGNO == HARD_IX_REGNUM) || (REGNO == HARD_IY_REGNUM)))
+#define REGNO_OK_FOR_INDEX_P(REGNO)	0
+
+#define REGNO_OK_FOR_BASE_P(REGNO)                  \
+    ((REGNO) < FIRST_PSEUDO_REGISTER ? REG_VALID_FOR_BASE_P (REGNO) \
+          : (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))
+
+#define REGNO_OK_FOR_BASE_P2(REGNO,STRICT)          \
+      ((STRICT) ? (REGNO_OK_FOR_BASE_P (REGNO)):REGNO_OK_FOR_BASE_NONSTRICT_P (REGNO))
+
+extern short *reg_renumber; /* def in local_alloc.c */
+
+/* Internal macro, the nonstrict definition for REGNO_OK_FOR_BASE_P.  */
+#define REGNO_OK_FOR_BASE_NONSTRICT_P(REGNO) \
+           ((REGNO) >= FIRST_PSEUDO_REGISTER \
+             || REG_VALID_FOR_BASE_P (REGNO) \
+             || (REGNO) == FRAME_POINTER_REGNUM \
+            || (REGNO) == ARG_POINTER_REGNUM \
+            || (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))
+
+
+
+
+/* see PUSH_POP_ADDRESS_P() below for an explanation of this.  */
+#define IS_STACK_PUSH(operand) \
+    ((GET_CODE (operand) == MEM) \
+     && (GET_CODE (XEXP (operand, 0)) == PRE_DEC) \
+     && (SP_REG_P (XEXP (XEXP (operand, 0), 0))))
+
+#define IS_STACK_POP(operand) \
+    ((GET_CODE (operand) == MEM) \
+     && (GET_CODE (XEXP (operand, 0)) == POST_INC) \
+     && (SP_REG_P (XEXP (XEXP (operand, 0), 0))))
+
+/* 1 if X is an rtx for a constant that is a valid address.  */
+#define CONSTANT_ADDRESS_P(X)	(CONSTANT_P (X))
+
+/* Maximum number of registers that can appear in a valid memory address */
+#define MAX_REGS_PER_ADDRESS	2
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression that is a
+   valid memory address for an instruction. The MODE argument is the
+   machine mode for the MEM expression that wants to use this address.  */
+
+/*--------------------------------------------------------------
+   Valid addresses are either direct or indirect (MEM) versions
+   of the following forms:
+	constant		N
+	register		,X
+	indexed			N+X
+--------------------------------------------------------------*/
+
+/* The range of index that is allowed by indirect addressing. */
+
+#define VALID_MIN_OFFSET z80_min_offset
+#define VALID_MAX_OFFSET z80_max_offset
+
+/* The offset values which are allowed by the n,x and n,y addressing modes.
+*/
+
+#define VALID_CONSTANT_OFFSET_P(X,MODE)		\
+((GET_CODE (X) == CONST_INT) &&			\
+ ((INTVAL (X) >= VALID_MIN_OFFSET)		\
+    && ((INTVAL (X) <= VALID_MAX_OFFSET	\
+		- (HOST_WIDE_INT) (GET_MODE_SIZE (MODE) + 1)))))
+
+/* This is included to allow stack push/pop operations. Special hacks in the
+   md and z80.c files exist to support this.  */
+#define PUSH_POP_ADDRESS_P(X) \
+  (((GET_CODE (X) == PRE_DEC) || (GET_CODE (X) == POST_INC)) \
+	&& SP_REG_P (XEXP (X, 0)))
+
+/* Go to ADDR if X is a valid address. */
+
+#ifndef REG_OK_STRICT
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \
+{ \
+  if (z80_go_if_legitimate_address ((X), (MODE), 0)) goto ADDR; \
+}
+#else
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)		 \
+{							 \
+  if (z80_go_if_legitimate_address ((X), (MODE), 1)) goto ADDR; \
+}
+#endif
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check its
+   validity for a certain class.  We have two alternate definitions for each
+   of them.  The usual definition accepts all pseudo regs; the other rejects
+   them unless they have been allocated suitable hard regs.  The symbol
+   REG_OK_STRICT causes the latter definition to be used.
+  
+   Most source files want to accept pseudo regs in the hope that they will
+   get allocated to the class that the insn wants them to be in. Source files
+   for reload pass need to be strict. After reload, it makes no difference,
+   since pseudo regs have been eliminated by then.  */
+
+#ifndef REG_OK_STRICT
+/* Nonzero if X is a hard reg that can be used as a base reg.  */
+#define REG_OK_FOR_BASE_P(X)   REGNO_OK_FOR_BASE_NONSTRICT_P(REGNO(X))
+#define REG_OK_FOR_INDEX_P(X) 	(0)   
+
+/* Nonzero if X is a hard reg that can be used as an index.  */
+#else
+#define REG_OK_FOR_BASE_P(X)   REGNO_OK_FOR_BASE_P(REGNO(X))
+#define REG_OK_FOR_INDEX_P(X) 	(0)  
+#endif
+
+
+/* Try machine-dependent ways of modifying an illegitimate address
+   to be legitimate.  If we find one, return the new, valid address.
+   This macro is used in only one place: `memory_address' in explow.c.
+  
+   OLDX is the address as it was before break_out_memory_refs was called.
+   In some cases it is useful to look at this to decide what needs to be done.
+  
+   MODE and WIN are passed so that this macro can use
+   GO_IF_LEGITIMATE_ADDRESS.
+  
+   It is always safe for this macro to do nothing.
+   It exists to recognize opportunities to optimize the output.  
+ 
+ When the offset goes out of range in indexed addressing mode,
+  we will force the displacement in to a register and add it to the ix register.
+ May be that we can better handle this case in LEGITIMIZE_RELOAD_ADDRESS.
+ 
+ */
+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)               \
+{                                    \
+  if (GET_CODE (X) == PLUS                                              \
+      && GET_CODE (XEXP (X, 0)) == REG                                  \
+      && GET_CODE (XEXP (X, 1)) == CONST_INT                            \
+      && !VALID_CONSTANT_OFFSET_P (XEXP (X, 1), MODE))                  \
+    {                                                                   \
+      rtx xop0 = XEXP (X, 0);                        \
+      rtx xop1 = XEXP (X, 1);                        \
+      xop1 = force_reg (Pmode, xop1);                 \
+ 	 (X) = force_reg (Pmode, gen_rtx_PLUS (Pmode, xop0, xop1)); \
+      goto WIN;                         \
+    }                                \
+}
+
+/* Go to LABEL if ADDR (a legitimate address expression)
+   has an effect that depends on the machine mode it is used for.  */
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \
+{									\
+  if (GET_CODE (ADDR) == PRE_DEC || GET_CODE (ADDR) == POST_DEC		\
+      || GET_CODE (ADDR) == PRE_INC || GET_CODE (ADDR) == POST_INC)	\
+    goto LABEL;								\
+}
+
+/* Nonzero if the constant value X is a legitimate general operand.
+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+
+#define LEGITIMATE_CONSTANT_P(X)	1
+
+
+/* Tell final.c how to eliminate redundant test instructions.  
+ need to check this. 
+ This needs to be improved. (??)
+ 
+ */
+
+#define NOTICE_UPDATE_CC(EXP, INSN)                 \
+{ if (GET_CODE (EXP) == SET)                        \
+    {                                   \
+      notice_update_cc_on_set(EXP, INSN);               \
+    }                                   \
+  else if (GET_CODE (EXP) == PARALLEL                   \
+           && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)            \
+    {                                   \
+      notice_update_cc_on_set(XVECEXP (EXP, 0, 0), INSN);       \
+    }                                   \
+  else if (GET_CODE (EXP) == CALL)                  \
+    { /* all bets are off */ CC_STATUS_INIT; }              \
+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG        \
+      && cc_status.value2                       \
+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))  \
+    {                                   \
+      printf ("here!\n");                       \
+      cc_status.value2 = 0;                     \
+    }                                   \
+}
+
+/* Cost macros : These are not fully relevant to z80. I have given some default
+ values to these macros.  These needs to be defined correctly. The
+ confusion here is we have instructions to operate on one byte operands and
+ instructions to operate on 2 byte (size) operands, which have differsnt costs
+ in themselves. */
+
+
+
+/* Compute the cost of computing a constant rtl expression RTX whose rtx-code
+   is CODE.  The body of this macro is a portion of a switch statement.  If
+   the code is computed here, return it with a return statement. Otherwise,
+   break from the switch.  */
+
+/* The cost macros are given some default values or not exact values.
+ These needs to be improved.
+ 
+ Trying to fix these.....
+ */
+
+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \
+ case CONST_INT:			 \
+    if (RTX == const0_rtx) return 0;	 \
+ case CONST:				 \
+    return 0;                            \
+ case LABEL_REF:			 \
+ case SYMBOL_REF:			 \
+   return 1;				 \
+ case CONST_DOUBLE:			 \
+   return 0;
+
+#define DEFAULT_RTX_COSTS(X,CODE,OUTER_CODE)		\
+    return z80_rtx_costs (X, CODE, OUTER_CODE);
+
+/* An expression giving the cost of an addressing mode that contains
+   ADDRESS.  If not defined, the cost is computed from the ADDRESS
+   expression and the `CONST_COSTS' values.  */
+
+#define ADDRESS_COST(RTX) \
+  ((CONSTANT_P (RTX)						\
+    || (GET_CODE (RTX) == PLUS && CONSTANT_P (XEXP (RTX, 1))	\
+	&& REG_P (XEXP (RTX, 0)))) ? 0				\
+   : REG_P (RTX) ? 4						\
+   : 2)
+
+#define REGISTER_MOVE_COST(CLASS1, CLASS2)		\
+		(((CLASS1) == Q_REGS && (CLASS2) == Q_REGS)?2:4) 
+
+#define MEMORY_MOVE_COST(MODE,CLASS,IN)	\
+	((MODE) == QImode ?4:6)
+
+/* A C expression for the cost of a branch instruction.  A value of 1
+   is the default; other values are interpreted relative to that.
+
+   Pretend branches are cheap because GCC generates sub-optimal code
+   for the default value.  */
+#define BRANCH_COST 0
+
+/* Nonzero if access to memory by bytes is slow and undesirable.  */
+#define SLOW_BYTE_ACCESS	0
+
+/* It is as good to call a constant function address as to call an address
+   kept in a register.  */
+#define NO_FUNCTION_CSE
+
+
+
+/* Defining the Output Assembler Language.  */
+
+/* A default list of other sections which we might be "in" at any given
+   time.  For targets that use additional sections (e.g. .tdesc) you
+   should override this definition in the target-specific file which
+   includes this file.  */
+
+/* Output before read-only data.  */
+#define TEXT_SECTION_ASM_OP	("\t.section\t.text")
+
+/* Output before writable data.  */
+#define DATA_SECTION_ASM_OP	("\t.section\t.data")
+
+/* Output before uninitialized data.  */
+#define BSS_SECTION_ASM_OP 	("\t.section\t.bss")
+
+/* This is how to begin an assembly language file.  Most svr4 assemblers want
+   at least a .file directive to come first, and some want to see a .version
+   directive come right after that.  Here we just establish a default
+   which generates only the .file directive.  If you need a .version
+   directive for any specific target, you should override this definition
+   in the target-specific file which includes this one.  */
+
+#undef ASM_FILE_START
+#define ASM_FILE_START(FILE)                            \
+    z80_asm_file_start ((FILE), main_input_filename)
+
+/* Comment character */
+#define ASM_COMMENT_START	"#"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+#define ASM_APP_ON 		"# Begin inline assembler code\n#APP\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+#define ASM_APP_OFF 		"# End of inline assembler code\n#NO_APP\n"
+
+/* Output #ident as a .ident.  */
+
+/* This is how to output a `long double' extended real constant.  */
+
+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  				\
+    ASM_OUTPUT_DOUBLE(FILE,VALUE)
+
+/* This is how to output an assembler line defining a `double' constant.  */
+
+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)					\
+do { long l[2];								\
+     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);				\
+     fprintf (FILE, "\t%s\t0x%lx,0x%lx\n", ASM_LONG, l[0], l[1]);	\
+   } while (0)
+
+/* This is how to output an assembler line defining a `float' constant.  */
+
+#define ASM_OUTPUT_FLOAT(FILE,VALUE)			\
+do { long l;						\
+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);		\
+     fprintf ((FILE), "\t%s\t0x%lx\n", ASM_LONG, l);	\
+   } while (0)
+
+/* This is how to output an assembler line defining a `long' constant.  */
+#define ASM_OUTPUT_INT(FILE,VALUE)		        \
+( fprintf (FILE, "\t%s\t", ASM_LONG),			\
+  output_addr_const (FILE, (VALUE)),			\
+  fprintf (FILE, "\n"))
+
+/* Likewise for `char' and `short' constants.  */
+#define ASM_OUTPUT_SHORT(FILE,VALUE)			\
+( fprintf (FILE, "\t%s\t", ASM_SHORT),			\
+  output_addr_const (FILE, (VALUE)),			\
+  fprintf (FILE, "\n"))
+
+/* This is how to output an assembler line for a numeric constant byte.  */
+#define ASM_OUTPUT_CHAR(FILE,VALUE)			\
+( fprintf (FILE, "\t%s\t", ASM_BYTE_OP),		\
+  output_addr_const (FILE, (VALUE)),			\
+  putc ('\n', FILE))
+
+#define ASM_OUTPUT_BYTE(FILE,VALUE)			\
+  fprintf ((FILE), "%s 0x%x\n", ASM_BYTE_OP, (VALUE))
+
+
+/* Define the parentheses used to group arithmetic operations in assembler
+ * code.  
+ */
+#define ASM_OPEN_PAREN		"("
+#define ASM_CLOSE_PAREN		")"
+
+/* This is how to output the definition of a user-level label named NAME,
+   such as the label on a static function or variable NAME.  */
+
+#define ASM_OUTPUT_LABEL(FILE,NAME)	\
+  do { assemble_name (FILE, NAME); fputs (":\n", FILE); } while (0)
+
+
+/* This is how to output a command to make the user-level label named NAME
+   defined for reference from other files.  */
+
+#define ASM_GLOBALIZE_LABEL(FILE,NAME)	\
+  do { fprintf (FILE, "%s ", GLOBAL_ASM_OP);		\
+       assemble_name (FILE, NAME);			\
+       fputs ("\n", FILE);} while (0)
+
+/* output external reference */
+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) \
+  {fputs ("\t# extern\t", FILE); \
+  assemble_name (FILE, NAME); \
+  fputs ("\n", FILE);}
+
+
+
+/* Store in OUTPUT a string (made with alloca) containing
+   an assembler-name for a local static variable named NAME.
+   LABELNO is an integer which is different for each call.  */
+
+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)	\
+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),	\
+  sprintf ((OUTPUT), "%s.%d", (NAME), (LABELNO)))
+
+/* How to refer to registers in assembler output.  This sequence is indexed
+   by compiler's hard-register-number (see above).  */
+#define REGISTER_NAMES						\
+{ "a", "hl", "de", "bc", "iy", "ix", "sp", "pc", "h",		\
+  "l", "d", "e", "b", "c", "f","ixl", "ixh", "iyl", "iyh"}
+
+
+/* Output a float value (represented as a C double) as an immediate operand.
+   This macro is a 68k-specific macro.  */
+
+#define ASM_OUTPUT_FLOAT_OPERAND(CODE,FILE,VALUE)		\
+ do {								\
+      long l;							\
+      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);			\
+      asm_fprintf ((FILE), "%I0x%lx", l);			\
+     } while (0)
+
+/* Output a double value (represented as a C double) as an immediate operand.
+   This macro is a 68k-specific macro.  */
+#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)				\
+ do { char dstr[30];							\
+      REAL_VALUE_TO_DECIMAL (VALUE, "%.20g", dstr);			\
+      asm_fprintf (FILE, "%I0r%s", dstr);				\
+    } while (0)
+
+/* Note, long double immediate operands are not actually
+   generated by m68k.md.  */
+#define ASM_OUTPUT_LONG_DOUBLE_OPERAND(FILE,VALUE)			\
+ do { char dstr[30];							\
+      REAL_VALUE_TO_DECIMAL (VALUE, "%.20g", dstr);			\
+      asm_fprintf (FILE, "%I0r%s", dstr);				\
+    } while (0)
+
+/* Print an instruction operand X on file FILE. CODE is the code from the
+   %-spec for printing this operand. If `%z3' was used to print operand
+   3, then CODE is 'z'.  */
+
+#define PRINT_OPERAND(FILE, X, CODE)					\
+{									\
+	if (CODE == '#') 						\
+		fprintf (FILE, "#");					\
+	else if (CODE == 'h')						\
+	{								\
+	if (GET_CODE (X) == REG && GET_MODE (X) == QImode && !Q_REG_P(X))\
+		X = z80_gen_highpart (QImode, X);			\
+	fprintf (FILE, "%s", reg_names[REGNO (X)]);            		\
+	}								\
+	else if (CODE == 'H')						\
+	{								\
+	if (GET_CODE (X) == REG && H_REG_P (X))\
+		X = z80_gen_highpart (QImode, X);			\
+	fprintf (FILE, "%s", reg_names[REGNO (X)]);            		\
+	}								\
+	else if (GET_CODE (X) == REG)					\
+	{								\
+		if (!Q_REG_P (X)  && GET_MODE (X) ==QImode)    	        \
+			X = z80_gen_lowpart (QImode, X);      	        \
+		fprintf (FILE, "%s", reg_names[REGNO (X)]);		\
+	}               						\
+	else if (GET_CODE (X) == PLUS){					\
+		print_operand_address (FILE, X); \
+	}\
+	else if (GET_CODE (X) == MEM)					\
+		output_address (XEXP (X, 0));				\
+	else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != SImode)\
+	{								\
+		union { double d; int i[2]; } u;			\
+		u.i[0]=CONST_DOUBLE_LOW (X); u.i[1]=CONST_DOUBLE_HIGH (X);\
+		fprintf (FILE, "%.20e", u.d);				\
+	}								\
+	else								\
+	{								\
+		output_addr_const (FILE, X);		\
+	}								\
+}
+
+
+/* Print a memory operand whose address is X, on file FILE. */
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \
+  print_operand_address (FILE, ADDR)
+
+/* This is how to output an insn to push/pop a register on the stack.
+   It need not be very fast code.  
+*/
+
+
+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)			\
+  fprintf (FILE, "\tpush\t%s\n", reg_names[REGNO])
+
+#define ASM_OUTPUT_REG_POP(FILE,REGNO)			\
+  fprintf (FILE, "\tpop\t%s\n", reg_names[REGNO])
+
+/* This is how to output an element of a case-vector that is relative. */
+
+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \
+  asm_fprintf (FILE, "\t%s\tL%d-L%d\n", ASM_SHORT, VALUE, REL)
+
+/* This is how to output an element of a case-vector that is absolute. */
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \
+  asm_fprintf (FILE, "\t%s\t.L%d\n", ASM_SHORT, VALUE)
+
+#undef ASM_OUTPUT_LABELREF
+#define ASM_OUTPUT_LABELREF(FILE, NAME)	          \
+  do {                                            \
+  char* real_name;                                \
+  STRIP_NAME_ENCODING (real_name, (NAME));        \
+  fprintf (FILE, "_%s", real_name);               \
+  } while (0)           
+
+/* This is how to output an assembler line that says to advance the
+   location counter to a multiple of 2**LOG bytes.  */
+#define ASM_OUTPUT_ALIGN(FILE,LOG)			\
+  do {                                                  \
+      if ((LOG) > 1)                                    \
+          asm_fprintf ((FILE), "\t%s\n", ALIGN_ASM_OP); \
+  } while (0)
+
+
+/* Assembler Commands for Exception Regions.  */
+
+/* Default values provided by GCC should be ok. Assumming that DWARF-2
+   frame unwind info is ok for this platform. */
+
+/* How to renumber registers for dbx and gdb. */
+#define DBX_REGISTER_NUMBER(REGNO) \
+ ((REGNO))
+
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG
+
+/* The prefix for local labels.  You should be able to define this as
+   an empty string, or any arbitrary string (such as ".", ".L%", etc)
+   without having to make any other changes to account for the specific
+   definition.  Note it is a string literal, not interpreted by printf
+   and friends. */
+#define LOCAL_LABEL_PREFIX "."
+
+/* The prefix for immediate operands.  */
+//#define IMMEDIATE_PREFIX "#"
+#define GLOBAL_ASM_OP   ".globl"
+#define ASM_LONG        ".long"
+#define ASM_SHORT       ".word"
+
+
+/* Miscellaneous Parameters.  */
+
+/* Define the codes that are matched by predicates in m68hc11.c.  */
+#define PREDICATE_CODES \
+{"stack_register_operand",   {SUBREG, REG}},				\
+{"hard_reg_operand",         {SUBREG, REG}},				\
+{"non_push_operand",         {SUBREG, REG, MEM}},			\
+{"reg_or_some_mem_operand",  {SUBREG, REG, MEM}},			\
+{"tst_operand",              {SUBREG, REG, MEM}},			\
+{"cmp_operand",              {SUBREG, REG, MEM, SYMBOL_REF, LABEL_REF,	\
+			     CONST_INT, CONST_DOUBLE}},
+
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE	Pmode
+
+/* Specify the tree operation to be used to convert reals to integers. */
+#define IMPLICIT_FIX_EXPR	FIX_ROUND_EXPR
+
+/* This flag, if defined, says the same insns that convert to a signed fixnum
+   also convert validly to an unsigned one.  */
+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC
+
+/* This is the kind of divide that is easiest to do in the general case.  */
+#define EASY_DIV_EXPR		TRUNC_DIV_EXPR
+
+/* Max number of bytes we can move from memory to memory in one
+   reasonably fast instruction.  */
+#define MOVE_MAX 		2
+
+/* MOVE_RATIO is the number of move instructions that is better than a
+   block move.  Make this small on 6811, since the code size grows very
+   large with each move.  */
+#define MOVE_RATIO		3
+
+/* Define if shifts truncate the shift count which implies one can omit
+   a sign-extension or zero-extension of a shift count.  */
+#define SHIFT_COUNT_TRUNCATED	1
+
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)	1
+
+/* Specify the machine mode that pointers have. After generation of rtl, the
+   compiler makes no further distinction between pointers and any other
+   objects of this machine mode.  */
+#define Pmode			HImode
+
+/* A function address in a call instruction is a byte address (for indexing
+   purposes) so give the MEM rtx a byte's mode.  */
+#define FUNCTION_MODE		QImode
+
+/* define SCCS_DIRECTIVE if SCCS directives should be ignored */
+#define SCCS_DIRECTIVE		1
+
+/* Allow $ in identifiers */
+#define DOLLARS_IN_IDENTIFIERS	1
+
+extern long z80_min_offset;
+extern long z80_max_offset;
+extern int current_function_interrupt;
+extern int current_function_trap;
+extern rtx_ptr z80_compare_op0;
+extern rtx_ptr z80_compare_op1;
+
diff -Naur gcc-2.95.2/gcc/config/z80/z80.md gcc-2.95.2-z80/gcc/config/z80/z80.md
--- gcc-2.95.2/gcc/config/z80/z80.md	Thu Jan  1 05:30:00 1970
+++ gcc-2.95.2-z80/gcc/config/z80/z80.md	Fri Jun  8 19:31:17 2001
@@ -0,0 +1,2628 @@
+;; GNU CC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; GNU CC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU CC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+;; Note:
+;; This work is carried out as a paart of my learning. The port needs to be 
+;; improved in many aspects.(The port is not complete yet).
+ 
+
+
+;;- Instruction patterns.  When multiple patterns apply,
+;;- the first one in the file is chosen.
+;;-
+;;- See file "rtl.def" for documentation on define_insn, match_*, et. al.
+;;-
+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code
+;;- updates for most instructions. (This needs to be improved).
+
+;;
+;; The following constraints are used:
+;;
+;; Single pair registers:
+;; a    register 'a'			 8-bit
+;; b    register 'bc'			 16-bit
+;; d    register 'de'			16-bit
+;; w    register 'sp'			16-bit 
+;; x    register 'x'			16-bit
+;; y    register 'y'			16-bit
+;; D    register 'hl+de'			32-bit 
+;; u    register 'bc+iy'			32-bit 
+;;
+;; Group of registers:
+;; q    register 'a' or 'b' ,'c','d' , 'e', 'ixh, 'ixl' , 'iyh', 'iyl'	 8-bit
+;; A    register 'x', 'y'               16-bit
+;; z	register 'hl', 'ix', 'iy'	16-bit
+;;
+;;
+;; Immediate integer operand constraints:
+;;   `L' is for range -65536 to 65536
+;;   `M' is for values whose 16-bit low part is 0
+;;   'N' is for +1 or -1.
+;;
+;; In many cases, it's not possible to use the 'g' or 'r' constraints.
+;;
+
+
+;;QImode values are not allowed in ix and iy registers. We might 
+;; have to allow (I guess). May be when I compile some big code, I might be
+;; knowing about this.
+
+;; 32-bit Patterns:
+;;     The z80 does not support 32-bit operations. Most of the
+;;     32-bit patterns are defined to split the instruction in
+;;     16-bits patterns. Providing split patterns generates better code
+;;     than letting GCC implement the 3264-bit operation itself.
+;;
+;;
+;; In test and compare patterns we save the operands and use them in the branch 
+;; patterns, which actually emits a compare and branch instructions.
+;; We really do not use test define_insn  patterns because for testing
+;; an operand we need a compare instuction (sbc), which needs both the 
+;; operands to be in registers. 
+;;We generate compare patterns with the saved 
+;;operands in the following branch patterns
+
+(define_expand "tstsi"
+  [(set (cc0)
+	(match_operand:SI 0 "tst_operand" ""))]
+  ""
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = const0_rtx;
+  DONE;
+}")
+
+(define_expand "tsthi"
+  [(set (cc0)
+	(match_operand:HI 0 "tst_operand" ""))]
+  ""
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = const0_rtx;
+  DONE;
+}")
+
+(define_insn "tsthi_1"
+  [(set (cc0)
+        (match_operand:HI 0 "tst_operand" "h"))]
+  "0"
+  "sbc\\t%0,0")
+
+(define_expand "tstqi"
+  [(set (cc0)
+	(match_operand:QI 0 "tst_operand" ""))]
+  ""
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = const0_rtx;
+  DONE;
+}")
+
+;;--------------------------------------------------------------------
+;;- Compare
+;;--------------------------------------------------------------------
+
+(define_expand "cmpsi"
+  [(set (cc0)
+	(compare (match_operand:SI 0 "tst_operand" "")
+		 (match_operand:SI 1 "cmp_operand" "")))]
+  ""
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = operands[1];
+  DONE;
+}")
+
+(define_expand "cmphi"
+  [(set (cc0)
+	(compare (match_operand:HI 0 "tst_operand" "")
+		 (match_operand:HI 1 "cmp_operand" "")))]
+  ""
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = operands[1];
+  DONE;
+}")
+
+(define_insn "cmphi_1"
+  [(set (cc0)
+        (compare (match_operand:HI 0 "tst_operand" "h")
+                 (match_operand:HI 1 "cmp_operand" "hbd")))]
+  ""
+"*
+{
+	operands[2] = gen_rtx_REG (QImode, HARD_A_REGNUM);   
+	output_asm_insn (\"or\\t%2,%2\", operands);
+    return\"sbc\\t%0,%1\";
+}")
+
+
+(define_expand "cmpqi"
+  [(set (cc0)
+	(compare (match_operand:QI 0 "tst_operand" "")
+		 (match_operand:QI 1 "cmp_operand" "")))]
+  ""
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = operands[1];
+  DONE;
+}")
+
+
+(define_insn "cmpqi_1"
+  [(set (cc0)
+        (compare (match_operand:QI 0 "tst_operand" "a")
+                 (match_operand:QI 1 "cmp_operand" "r")))]
+  ""
+  "*
+{
+   return \"cp\\t%0,%1\";
+}")
+
+
+
+(define_expand "cmpdf"
+  [(set (cc0)
+	(compare (match_operand:DF 0 "general_operand" "")
+		 (match_operand:DF 1 "general_operand" "")))]
+  "0"
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = operands[1];
+  DONE;
+}")
+
+(define_expand "cmpsf"
+  [(set (cc0)
+	(compare (match_operand:SF 0 "general_operand" "")
+		 (match_operand:SF 1 "general_operand" "")))]
+  "0"
+  "
+{
+  z80_compare_op0 = operands[0];
+  z80_compare_op1 = operands[1];
+  DONE;
+}")
+
+
+
+;;--------------------------------------------------------------------
+;;-  Jumps and transfers
+;;--------------------------------------------------------------------
+
+;; We use the operands saved in test/compare patterns and emit the code
+;;for compares and branches.
+;;;;;;;; On Z80 we do n't have instructions for branching when the branch code
+;;is GT, GTU, LE and LEU. So, when any of these codes are encountered we
+;; swap the opernds followed by the comparision code.
+;;The expands call a z80_expand_compare function from z80.c file with the
+;;operands, comparision code and with argument 1. This is to indicate
+;; you want to emit the code  (default).
+;; Reason for the last argument: We need to emit two compares and a branch
+;; for long value compares and branches. To distinguish between the scenarios.
+;; should look for a better approach.
+
+(define_expand "beq"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (EQ, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "bne"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (NE, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "bgt"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (GT, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "bgtu"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (GTU, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "blt"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (LT, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "bltu"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (LTU, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "bge"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+z80_expand_compare_and_branch (GE, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "bgeu"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (GEU, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "ble"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (LE, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_expand "bleu"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "
+{
+ z80_expand_compare_and_branch (LEU, z80_compare_op0,
+				     z80_compare_op1, operands[0],1);
+  DONE;
+}")
+
+(define_insn "*beq"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "jr\\tz,%l0")
+
+(define_insn "*bne"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+""
+"jr\\tnz,%l0")
+
+/* actually there is no instruction to test for the gt,le
+													gtu and leu 
+ So, we are canonicalizing the instructions for gt to lt
+												le to ge
+												gtu to ltu
+												leu to geu
+		by sawpping the operands.					*/
+
+;;need to call a function setflag to  clear/set the sign flag based on the
+;;overflow. (needs to go in libgcc1.). If the p/v bit of flags register is set
+;;means I need to  
+;; This should happen when you are jumping based on the sign flag, i.e m or p
+;; in jp instruction.
+
+
+
+(define_insn "*bgt"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "*
+{
+ return \"jp\\tp,%l0\";
+}")
+
+(define_insn "*bgtu"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+""
+"*
+{
+ return \"jr\\tnc,%l0\";
+}")
+
+(define_insn "*blt"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "jp\\tm,%l0")
+
+
+(define_insn "*bltu"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+""
+"jr\\tc,%l0")
+
+(define_insn "*bge"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "jp\\tp,%l0")
+
+(define_insn "*bgeu"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+""
+"jr\\tnc,%l0")
+
+;; no actual branch for the two.
+ 
+
+(define_insn "*ble"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "*
+{
+return\"jp\\tm,%l0\";
+}")
+
+(define_insn "*bleu"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+""
+"*
+{
+ return \"jr\\tc,%l0\";
+}")
+  
+;;--------------------------------------------------------------------
+;;- Negative test and branch
+;;--------------------------------------------------------------------
+
+;;negative braches. We nee to look more closely for the ones which we 
+;;do n't have the instructions.guess!!! we need to jump on reverse conditions.
+;;check the output template.
+
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+""
+"jr\\tnz,%l0")
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+""
+"jr\\tz,%l0")
+
+;;no branch insn for le. 
+ 
+(define_insn ""
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "jp\\tm,%l0")
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+"jr\\tc,%l0")
+
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+""
+"jp\\tp,%l0")
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+""
+"jr\\tnc,%l0")
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+""
+"jp\\tm,%l0")
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+""
+"jr\\t%c,%l0")
+
+; no instruction for branchining on gt. 
+  
+(define_insn ""
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+ "jp\\tp,%l0")
+
+(define_insn ""
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+"jr\\tnc,%l0")
+
+;;--------------------------------------------------------------------
+;;-  Move strict_low_part
+;;--------------------------------------------------------------------
+;;
+;; The (strict_low_part ...) patterns are replaced by normal (set) patterns.
+;; The replacement must be made at the very end because we loose the
+;; (strict_low_part ...) information.  This is correct for our machine
+;; description but not for GCC optimization passes.
+;;
+
+;;-----------------------
+(define_insn "movstrictsi"
+  [(set (strict_low_part (match_operand:SI 0 "non_push_operand" "=Dm"))
+	(match_operand:SI 1 "general_operand" "Dim"))]
+""  
+"#")
+
+
+;;-----------------------
+(define_split
+  [(set (strict_low_part (match_operand:SI 0 "non_push_operand" "=Dm"))
+	(match_operand:SI 1 "general_operand" "Dim"))]
+  "reload_completed"
+  [(set (match_dup 0) (match_dup 1))]
+  "")
+
+
+
+(define_insn "movstricthi"
+  [(set (strict_low_part (match_operand:HI 0 "non_push_operand" "=rm"))
+	(match_operand:HI 1 "general_operand" "rmi"))]
+  ""    
+  "#")
+
+(define_split
+  [(set (strict_low_part (match_operand:HI 0 "non_push_operand" "=rm"))
+	(match_operand:HI 1 "general_operand" "rim"))]
+  "reload_completed"
+  [(set (match_dup 0) (match_dup 1))]
+  "")
+
+
+;;-----------------------
+(define_insn "movstrictqi"
+  [(set (strict_low_part (match_operand:QI 0 "non_push_operand" "=rm"))
+	(match_operand:QI 1 "general_operand" "rim"))]
+  ""
+  "#")
+
+
+;;-----------------------
+(define_split
+  [(set (strict_low_part (match_operand:QI 0 "non_push_operand" "=rm"))
+	(match_operand:QI 1 "general_operand" "rim"))]
+  "reload_completed"
+  [(set (match_dup 0) (match_dup 1))]
+  "")
+
+
+;;--------------------------------------------------------------------
+;;- 32-bit Move Operations.
+;; The movsi and movsf patterns are identical except for the mode.
+;; When we move to/from a hard register (hl+de/bc+iy), we don't need a scratch.
+;; Otherwise, a scratch register is used as intermediate register for
+;; the move.  The '&' constraint is necessary to make sure the reload
+;; pass does not give us a register that dies in the insn and is used
+;; for input/output operands.
+;;--------------------------------------------------------------------
+(define_insn "movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=Du,r,m,m")
+	(match_operand:SI 1 "general_operand"      "Du,mi,r,mi"))
+   (clobber (match_scratch:HI 2                    "=X,X,X,&b"))]
+  ""
+  "#")
+
+(define_split
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,m,r,m")
+	(match_operand:SI 1 "general_operand" "r,r,mi,mi"))
+   (clobber (match_scratch:HI 2 "=X,X,X,&b"))]
+  "reload_completed"
+  [(const_int 0)]
+  "z80_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+(define_insn "movsf"
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,m,?r,m")
+	(match_operand:SF 1 "general_operand" "r,r,mi,mi"))
+   (clobber (match_scratch:HI 2 "=X,X,X,&b"))]
+  ""
+  "#")
+
+(define_split
+  [(set (match_operand:SF 0 "nonimmediate_operand" "=r,m,?r,m")
+	(match_operand:SF 1 "general_operand" "r,r,mi,mi"))
+   (clobber (match_scratch:HI 2 "=X,X,X,&b"))]
+  "reload_completed"
+  [(const_int 0)]
+  "z80_split_move (operands[0], operands[1], operands[2]);
+   DONE;")
+
+
+;-----------------------
+
+(define_insn "*movhi2_push"
+  [(set (match_operand:HI 0 "push_operand" "=<")
+	(match_operand:HI 1 "register_operand" "hbdx*y"))]
+  ""
+"push\\t%1")
+
+
+(define_insn "*movhi2_pop"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=hbdx*y")
+	(match_operand:HI 1 "pop_operand" ">"))]
+  ""
+"pop\\t%0")
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "")
+        (match_operand:HI 1 "general_operand" ""))]
+  ""
+  "
+{
+      if (GET_CODE (operands[0]) == MEM &&
+          (GET_CODE (operands[1]) == MEM
+           || GET_CODE (operands[1]) == CONST_INT))
+        {
+          operands[1] = force_reg (HImode, operands[1]);
+        }
+      else if (IS_STACK_PUSH (operands[0])
+                && GET_CODE (operands[1]) != REG)
+        {
+			operands[1] = force_reg (HImode, operands[1]);   
+		}
+}")
+
+
+(define_insn ""
+[(set (match_operand:HI 0 "register_operand" "=h!xy")
+	   (match_operand:HI 1 "stack_register_operand" "w"))]
+""
+"*
+{
+output_asm_insn (\"ld\\t%0,0\", operands);
+return \"add\\t%0,%1\";
+
+}")
+;; U is indexed memory and R is symbolic memory (Symbolic variables)
+;; In HImode we do n't have ld sp, (ix+d) and ld (ix+d),sp we might have to
+;; support this.
+
+(define_insn "*movhi"
+ [(set (match_operand:HI 0 "nonimmediate_operand" "=r,!w,hbd!x*y,m,!w,R,r")
+	(match_operand:HI 1 "general_operand" "0,h!xyi,m,hbd!x*y,R,!w,ri"))]
+""
+"*
+{
+
+if (which_alternative == 0)
+	return \"nop\";
+
+ if (which_alternative ==1)
+  return \"ld\\t%0,%1\";  
+ if (which_alternative ==2)
+  return \"ld\\t%0,(%1)\";
+ if (which_alternative == 3)  
+   return \"ld\\t(%0),%1\";
+ if (which_alternative ==4)
+  return \"ld\\t%0,(%1)\";
+ if (which_alternative ==5)
+  return \"ld\\t(%0),%1\";
+if (which_alternative == 6){
+	if (GET_CODE (operands[1]) == REG)
+	{
+		output_asm_insn (\"push\\t%1\", operands);
+		return \"pop\\t%0\";
+	}
+	else
+     return \"ld\\t%0,%1\";  
+}
+}")
+;;--------------------------------------------------------------------
+;;- 8-bit Move Operations.
+;; We need a scratch register when moving to/from symbolic memory.
+;;--------------------------------------------------------------------
+;;
+;;-----------------------
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  "
+{
+	if (GET_CODE (operands[0]) == MEM  &&  
+			 GET_CODE (operands[1]) == CONST_INT)
+	{
+		if(symbolic_memory_operand(operands[0], QImode))   
+			operands[1] = force_reg (QImode, operands[1]);
+	}
+
+	if (GET_CODE (operands[0]) == MEM
+		  && (GET_CODE (operands[1]) == MEM))
+      {
+		operands[1] = force_reg (QImode, operands[1]);
+      }
+
+   if (symbolic_memory_operand (operands[0], QImode) && !reload_in_progress)
+	{
+		  emit_insn (gen_storeqi (operands[0],operands[1]));
+      	  DONE;
+	}
+	else if (symbolic_memory_operand (operands[1], QImode) 
+			&& !reload_in_progress)
+	{
+   		 emit_insn (gen_storeqi (operands[0], operands[1]));
+	 	 DONE;
+	}
+}")
+
+/*
+  In QImode
+
+1) 
+   destination can be ---> a,b,c,d,e,h,l,ixh,ixl,iyh,iyl,(hl),(ix+d)
+   source can be     ---->  a,b,c,d,e,h,l,i
+
+ 2)
+  one more set is
+  destination can be --->      a,b,c,d,e
+   source can be   ----->      a,b,c,d,e,ixh,ixl,iyh,iyl,i,(ix+d)
+
+so, constraints are   
+			r,hbdai
+			U, hbdai  
+			abd, abdxyi
+			abd, U
+			a, R
+			R, a
+
+
+
+ no
+ ld iy, (ix+d)   and also ld (ix+d),iy
+ ld h,ixh
+
+*/
+
+(define_insn "*movqi"          
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,a,m,U,r")
+	(match_operand:QI 1 "general_operand" "0,ri,m,a,ri,U"))]
+ "GET_CODE (operands[1]) != SUBREG"
+"*
+{
+if (which_alternative == 0)
+  return \"nop\";
+if (which_alternative == 1)    //r and ri
+  return \"ld\\t%0,%1\";
+if (which_alternative == 2)   //a and m
+ return \"ld\\t%0,(%1)\";
+if (which_alternative == 3)  // m and a
+   return \"ld\\t(%0),%1\";
+if (which_alternative == 4){  // U and r  
+ return \"ld\\t(%0),%1\";
+}
+if (which_alternative == 5){ // r and U  
+return \"ld\\t%0,(%1)\";  
+}
+}")
+/* this needs to be examined closely, whenever truncating a SImode value to a QImode value it maps */
+
+(define_insn ""
+[(set (match_operand:QI 0 "nonimmediate_operand" "=m,r,r")
+    (match_operand:QI 1 "general_operand" "r,m,r"))]
+ "GET_CODE (operands[1]) == SUBREG"
+"*
+{
+if (which_alternative ==0)
+{
+//operands[2] = gen_rtx_REG (QImode, HARD_A_REGNUM);
+//output_asm_insn (\"ld\\t%2,%1\", operands);
+return \"ld\\t(%0),%1\";
+}
+if (which_alternative == 1)
+return \"ld\\t%0,(%1)\";
+if (which_alternative == 2)
+{
+		return \"ld\\t%0,%2\";
+
+}
+
+}")
+;; This can be made as loadstoreqi.
+
+(define_insn "storeqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=a,r,R,R")
+    (match_operand:QI 1 "general_operand" "R,R,a,r"))
+   (clobber (match_scratch:QI 2 "=X,&a,X,&a"))]
+  ""
+  "*
+{ 
+	if (which_alternative == 0)
+		return \"ld\\t%0,(%1)\";
+	if (which_alternative == 1)
+	{
+		operands[2] = gen_rtx_REG (QImode, REGNO (operands[2]));
+		output_asm_insn (\"ld\\t%2,(%1)\", operands);
+		return \"ld\\t%0,%2\";
+	}
+	if (which_alternative == 2){
+		return \"ld\\t(%0),%1\";
+	}
+	if (which_alternative == 3)
+	{
+		operands[2] = gen_rtx_REG (QImode, REGNO (operands[2]));
+		output_asm_insn (\"ld\\t%2,%1\", operands);
+		return \"ld\\t(%0),%2\";
+	} 
+}")
+
+
+
+
+
+
+ (define_expand "reload_inqi"
+  [(parallel [(set (match_operand:QI 0 "" "=r")
+           (match_operand:QI 1 "symbolic_memory_operand" "m"))
+          (clobber (match_operand:SI 2 "" "=&a"))])]
+  ""
+  "")
+  
+(define_expand "reload_outqi"
+  [(parallel [(set (match_operand:QI 0 "symbolic_memory_operand" "=m")
+           (match_operand:QI 1 "" "r"))
+          (clobber (match_operand:SI 2 "" "=&a"))])]
+  ""
+  "")
+
+(define_insn "swap_areg"
+   [(set (match_operand:HI 0 "register_operand" "")
+         (match_operand:HI 1 "register_operand" ""))
+    (set (match_dup 1) (match_dup 0))]
+   ""
+   "ex\\t%0,%1")
+
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (zero_extend:SI 
+	    (match_operand:HI 1 "register_operand" "r")))]   
+  ""
+  "#")
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI 
+	    (match_operand:HI 1 "register_operand" "r")))]
+  "reload_completed"
+[(set (match_dup 2) (match_dup 1))
+ (set (match_dup 3) (const_int 0))]
+
+"operands[2] = z80_gen_lowpart (HImode, operands[0]);
+ operands[3] = z80_gen_highpart (HImode, operands[0]);
+")
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+      (zero_extend:SI 
+	  (match_operand:QI 1 "register_operand" "r")))]
+  ""
+  "#")
+
+(define_split 
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (match_operand:QI 1 "register_operand" "r")))]
+  "reload_completed"
+[(set (match_dup 4) (match_dup 1))
+ (set (match_dup 5) (const_int 0))
+ (set (match_dup 3) (const_int 0))]
+
+"operands[2] = z80_gen_lowpart (HImode, operands[0]);
+ operands[3] = z80_gen_highpart (HImode, operands[0]);
+ operands[4] = z80_gen_lowpart (QImode, operands[2]);
+ operands[5] = z80_gen_highpart (QImode, operands[2]);")
+
+
+(define_insn "zero_extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(zero_extend:HI 
+	    (match_operand:QI 1 "register_operand" "a")))]
+  ""
+ "#")
+
+(define_split
+[(set (match_operand:HI 0 "register_operand" "=r")
+       (zero_extend:HI
+               (match_operand:QI 1 "register_operand" "a")))]      
+"reload_completed"
+
+[(set (match_dup 2) (match_dup 1))
+ (set (match_dup 3) (const_int 0))]            
+
+ "operands[2] = z80_gen_lowpart (QImode, operands[0]);
+ operands[3] = z80_gen_highpart (QImode, operands[0]);")
+
+(define_insn "extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (match_operand:QI 1 "register_operand" "a")))]  
+  ""
+ "#")
+
+
+(define_split
+[(set (match_operand:HI 0 "register_operand" "=r")
+       (sign_extend:HI (match_operand:QI 1 "register_operand" "a")))]
+"reload_completed"
+[(set (match_dup 2) (match_dup 1))
+(set (match_dup 1) (rotate:QI (match_dup 1) (reg:QI 14)))   
+(set (match_dup 1) (minus:QI (minus:QI (reg:QI 14) (match_dup 1)) (match_dup 1)))
+(set (match_dup 3) (match_dup 1))]
+"operands[2] = z80_gen_lowpart (QImode, operands[0]);
+operands[3] = z80_gen_highpart (QImode, operands[0]);
+")
+
+/* doubt about this */
+
+(define_insn "extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:QI 1 "register_operand" "a")))]
+  ""
+"#")
+
+(define_split
+[(set (match_operand:SI 0 "register_operand" "=D")
+       (sign_extend:SI (match_operand:QI 1 "register_operand" "a")))]
+"reload_completed"
+[(set (match_dup 2) (sign_extend:HI (match_dup 1)))      
+ (set (match_dup 5) (match_dup 4))
+ (set (match_dup 6) (match_dup 4))]
+
+"operands[2] = z80_gen_lowpart (HImode, operands[0]);
+ operands[3] = z80_gen_highpart (HImode, operands[0]);
+ operands[4] = z80_gen_highpart (QImode, operands[2]);
+ operands[5] = z80_gen_lowpart (QImode, operands[3]);
+ operands[6] = z80_gen_highpart (QImode, operands[3]);
+")
+
+
+(define_insn "extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:HI 1 "register_operand" "b")))
+	(clobber (match_scratch:QI 2 "=&a"))]
+ ""
+"#")
+
+(define_split
+[(set (match_operand:SI 0 "register_operand" "=D")
+       (sign_extend:SI (match_operand:HI 1 "register_operand" "b")))  
+	(clobber (match_scratch:QI 2 "=&a"))]
+"reload_completed"
+[(set (match_dup 8) (match_dup 5))   
+(set  (match_dup 8) (rotate:QI (match_dup 8) (reg:QI 14)))
+(set (match_dup 2) (minus:HI (minus:HI (reg:HI 14) (match_dup 2)) (match_dup 2)))
+(set (match_dup 3) (match_dup 2))
+(set (match_dup 2) (match_dup 1))]
+
+"operands[2] = z80_gen_lowpart (HImode, operands[0]);
+ operands[3] = z80_gen_highpart (HImode, operands[0]);  
+ operands[4] = z80_gen_lowpart (QImode, operands[1]);
+ operands[5] = z80_gen_highpart (QImode, operands[1]);
+operands[6] = z80_gen_lowpart (QImode, operands[2]);
+operands[7] = z80_gen_highpart (QImode, operands[2]);
+operands[8] =  gen_rtx_REG (QImode, HARD_A_REGNUM);")
+
+
+
+
+
+
+(define_insn "addsi3"
+  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+	(plus:SI (match_operand:SI 1 "register_operand" "%0")
+		 (match_operand:SI 2 "general_operand" "rmi")))
+       (clobber (match_scratch:HI 3 "=&b"))])]
+  ""
+"#")
+(define_split
+[(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+       (plus:SI (match_operand:SI 1 "register_operand" "%0")
+                (match_operand:SI 2 "general_operand" "rmi")))
+     (clobber (match_scratch:HI 3 "=&b"))])]
+"reload_completed"
+[(set (match_dup 3) (match_dup 6))
+(set (match_dup 4) (plus:HI (match_dup 4) (match_dup 3)))
+(set (match_dup 3) (match_dup 7)) 
+(parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))]) 
+(set (match_dup 4) (plus:HI (plus:HI (reg:HI 14) (match_dup 4)) (match_dup 3)))
+(parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))])] 
+
+"operands[4]=z80_gen_lowpart(HImode,operands[1]);
+ operands[5]=z80_gen_highpart(HImode,operands[1]);
+ operands[6]=z80_gen_lowpart(HImode,operands[2]);
+ operands[7]=z80_gen_highpart(HImode,operands[2]);")
+
+
+(define_expand "addhi3"
+[(set (match_operand:HI 0 "register_operand" "")
+      (plus:HI (match_operand:HI 1 "register_operand" "")
+                 (match_operand:HI 2 "general_operand" "")))]
+""
+"{
+	if (SP_REG_P (operands[0]))
+	{
+		emit_insn (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,
+			 gen_rtx (SET, VOIDmode,
+				  operands[0],gen_rtx (PLUS,HImode, operands[1],operands[2])), 
+			gen_rtx (CLOBBER, VOIDmode,
+				gen_rtx (SCRATCH, HImode)))));
+		DONE;
+	}
+}")
+
+(define_insn "addhi_sp"
+[(parallel[(set (match_operand:HI 0 "stack_register_operand" "!w")
+	  (plus:HI (match_operand:HI 1 "stack_register_operand" "0")
+		        (match_operand:HI 2 "general_operand" "g"))) 
+	(clobber (match_scratch:HI 3 "=&y"))])]
+  
+""
+"*
+{	operands[3] = gen_rtx_REG (HImode,HARD_IY_REGNUM);
+	if (GET_CODE (operands[2]) == MEM)
+	output_asm_insn (\"ld\\t%3,(%2)\", operands);
+	else
+	output_asm_insn (\"ld\\t%3,%2\", operands);
+	output_asm_insn (\"add\\t%3,%0\", operands);
+	output_asm_insn (\"ld\\t%0,%3\", operands);
+	return \"\";
+
+}")
+
+
+(define_insn ""
+[(set (match_operand:HI 0 "register_operand" "=r")
+       (plus:HI (match_operand:HI 1 "register_operand" "0")
+				 (const_int 1)))]  
+""
+"inc\\t%0")
+
+(define_insn ""
+[(set (match_operand:HI 0 "register_operand" "=r")
+       (plus:HI (match_operand:HI 1 "register_operand" "0")
+				 (const_int -1)))]  
+""  
+"dec\\t%0")
+
+(define_insn "addhi_mov"
+  [(set (match_operand:HI 0 "register_operand" "=hbdxy,xy")
+	(plus:HI (match_operand:HI 1 "address_register" "!xy,0")
+		 (match_operand:HI 2 "const_int_operand" "L,i")))]
+  ""
+  "*
+{
+
+	if (which_alternative ==0)
+	{
+		operands[3] = SET_SRC (PATTERN (insn));
+		return \"lea\\t%0,%3\";  
+	}
+	if (which_alternative == 1)
+	{
+		operands[3] = gen_rtx_REG (HImode, HARD_BC_REGNUM);
+		output_asm_insn (\"push\\t%3\", operands);
+		output_asm_insn (\"ld\\t%3,%2\", operands);
+		output_asm_insn (\"add\\t%0,%3\", operands);
+		return \"pop\\t%3\";
+	}
+}")
+
+
+
+/* In z80 add instruction allows hl,ix,iy as the first operand.
+	bc,de,hl and sp as the second operand.
+But still it will not allow add iy,hl or add ix,hl sequence.
+	So, we need to be careful about it.  */
+
+(define_insn "*addhi3"
+  [(set (match_operand:HI 0 "register_operand" "=h,xy,hxy,bd,xy")    
+	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,bd,0,0")
+		 (match_operand:HI 2 "general_operand" "hbd!w,bd!w,mi,hxy,h")))]
+  ""
+  "*
+{
+switch (which_alternative)
+{
+	case 0:
+		return \"add\\t%0,%2\";
+    case 1:
+		return \"add\\t%0,%2\";
+	case 2:
+		if (GET_CODE (operands[2]) == MEM)
+			output_asm_insn (\"ld\\t%0,(%2)\", operands);
+		else
+			output_asm_insn (\"ld\\t%0,%2\", operands);
+	    return \"add\\t%0,%1\";
+	case 3:
+		output_asm_insn (\"add\\t%2,%1\", operands);
+		return \"ld\\t%1,%2\";
+	case 4:
+		operands[3] = gen_rtx_REG (HImode, HARD_E_REGNUM);
+		output_asm_insn (\"ex\\t%2,%3\", operands);
+		output_asm_insn (\"add\\t%3,%0\", operands);
+		return\"ex\\t%2,%3\";   
+	default:
+		return \"\";
+}
+}")
+
+(define_insn "*adch"
+  [(set (match_operand:HI 0 "register_operand" "=h")
+        (plus:HI (plus:HI (reg:HI 14)
+                          (match_operand:HI 2 "register_operand" "%0"))
+                 (match_operand:HI 3 "register_operand" "hbd!w")))]
+  ""
+  "adc\\t%0,%3")
+
+
+
+
+(define_insn "addqi3"
+  [(set (match_operand:QI 0 "register_operand" "=a,r,a")
+	(plus:QI (match_operand:QI 1 "register_operand" "%0,0,0")
+		 (match_operand:QI 2 "general_operand" "U,N,ri")))]
+  ""
+  "*
+{
+switch (which_alternative)
+{
+	case 0:
+		return \"add\\t%0,(%2)\";
+	case 1:
+		if (INTVAL(operands[2]) == 1)
+			return \"inc\\t%0\";
+		else
+			return \"dec\\t%0\";
+	case 2:
+		return \"add\\t%0,%2\";
+	default:
+		break;
+}
+}")
+
+(define_insn "*adcq"
+  [(set (match_operand:QI 0 "register_operand" "=a")
+        (plus:QI (plus:QI (reg:QI 14)
+                          (match_operand:QI 2 "register_operand" "%0"))
+                 (match_operand:QI 3 "general_operand" "")))]
+  ""
+ "adc\\t%0,%3")
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(minus:SI (match_operand:SI 1 "register_operand" "0")
+		  (match_operand:SI 2 "general_operand" "rmi")))      
+   (clobber (match_scratch:HI 3 "=&b"))]   
+  ""
+  "#")
+
+;;-----------------------
+ (define_split            
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(minus:SI (match_operand:SI 1 "register_operand" "0")
+		  (match_operand:SI 2 "general_operand" "rmi")))   
+                   (clobber (match_scratch:HI 3 "=&d"))]   
+  "reload_completed && HL_REG_P (operands[1])"
+  [(set (match_dup 3) (match_dup 6))  
+  (set (match_dup 4) (minus:HI (match_dup 4) (match_dup 3)))
+  (set (match_dup 3) (match_dup 7))
+ (parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))]) 
+(set  (match_dup 4) (minus:HI (minus:HI (reg:HI 14) (match_dup 4)) (match_dup 5)))
+(parallel[(set (match_dup 4) (match_dup 5))(set (match_dup 5) (match_dup 4))])] 
+   "operands[4] = z80_gen_lowpart (HImode, operands[1]);
+   operands[5] = z80_gen_highpart (HImode, operands[1]);
+   operands[6] =z80_gen_lowpart (HImode, operands[2]);
+   operands[7] =z80_gen_highpart (HImode, operands[2]);")
+
+(define_insn "subhi3"
+  [(set (match_operand:HI 0 "register_operand" "=h")
+	(minus:HI (match_operand:HI 1 "register_operand" "%0")
+		  (match_operand:HI 2 "register_operand" "hbd")))]
+  ""
+  "*
+{
+	operands[3] = gen_rtx_REG (QImode, HARD_A_REGNUM);
+	output_asm_insn (\"or\\t%3,%3\", operands);
+  return \"sbc\\t%0,%2\";
+}")  
+
+(define_insn "*subchi3"
+  [(set (match_operand:HI 0 "register_operand" "=h")
+	(minus:HI (minus:HI (reg:HI 14) 
+                            (match_operand:HI 1 "register_operand" "%0"))
+		  (match_operand:HI 2 "register_operand" "r")))]
+  ""
+  "sbc\\t%0,%2")
+
+(define_insn "subqi3"
+  [(set (match_operand:QI 0 "register_operand" "=a")
+	(minus:QI (match_operand:QI 1 "register_operand" "%0")
+		  (match_operand:QI 2 "general_operand" "Uri")))]
+  ""
+  "*
+{
+	if (GET_CODE (operands[2]) == MEM)
+		return \"sub\\t%0,(%2)\";
+	else
+		return \"sub\\t%0,%2\";
+}")   
+
+(define_insn "*subcq"
+  [(set (match_operand:QI 0 "register_operand" "=a")
+        (minus:QI (minus:QI (reg:QI 14)
+                            (match_operand:QI 2 "register_operand" "0"))
+                  (match_operand:QI 3 "register_operand" "r")))]
+  ""
+  "sbc\\t%0,%3")
+
+(define_insn "andsi3"
+  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+	(and:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "general_operand" "Dim")))
+         (clobber (match_scratch:QI 3 "=&a"))
+         (clobber (match_scratch:HI 4 "=&b"))])]  
+ ""
+  "#")
+
+(define_split 
+  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+	(and:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "general_operand" "Dmi")))       
+         (clobber (match_scratch:QI 3 "=&a"))  
+         (clobber (match_scratch:HI 4 "=&b"))])] 
+"reload_completed"
+[(set (match_dup 4) (match_dup 7))
+(parallel[(set (match_dup 5) (and:HI (match_dup 5) (match_dup 4))) (clobber (reg:QI 0))])      
+ (set (match_dup 4) (match_dup 8))       
+(parallel[(set (match_dup 6) (and:HI (match_dup 6) (match_dup 4))) (clobber (reg:QI 0))])]
+   
+"operands[4] = gen_rtx_REG (HImode, REGNO (operands[4]));
+  operands[5] = z80_gen_lowpart (HImode, operands[1]);
+   operands[6] = z80_gen_highpart (HImode, operands[1]);
+   operands[7] = z80_gen_lowpart (HImode, operands[2]);
+   operands[8] = z80_gen_highpart (HImode, operands[2]);")  
+
+
+(define_insn "andhi3"
+  [(parallel[(set (match_operand:HI 0 "register_operand" "=r")
+	(and:HI (match_operand:HI 1 "register_operand" "%0")
+		(match_operand:HI 2 "register_operand" "r")))  
+        (clobber (match_scratch:QI 3 "=a"))])]
+  ""
+"#")
+
+(define_split 
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(and:HI (match_operand:HI 1 "register_operand" "%0")
+		(match_operand:HI 2 "register_operand" "r")))   
+        (clobber (match_scratch:QI 3 "=a"))]
+  "reload_completed"
+ [(set (match_dup 3) (match_dup 4))
+ (set (match_dup 3) (and:QI (match_dup 3) (match_dup 6) ))   
+ (set (match_dup 4) (match_dup 3))
+ (set (match_dup 3) (match_dup 5))
+ (set (match_dup 3) (and:QI (match_dup 3) (match_dup 7) ))
+ (set (match_dup 5) (match_dup 3))]
+"operands[4] = z80_gen_lowpart (QImode,operands[1] );
+   operands[5] = z80_gen_highpart (QImode, operands[1]);
+   operands[6] = z80_gen_lowpart (QImode,operands[2]);
+   operands[7] = z80_gen_highpart (QImode, operands[2]);") 
+
+(define_insn "andqi3"
+  [(set (match_operand:QI 0 "register_operand" "=a")
+        (and:QI (match_operand:QI 1 "register_operand" "%0")
+             (match_operand:QI 2 "general_operand" "U*ri")))]
+  ""
+  "*
+{
+	if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int val = INTVAL (operands[2]) & 0x0FF;
+
+      if (val == 0xFF)
+    {
+      cc_status = cc_prev_status;
+      return \"\";
+    }
+	if (val == 0)
+		return \"ld\\t%0,0\";
+	return \"and\\t%0,%1\";
+	}
+
+if (GET_CODE (operands[2]) == MEM)
+	return\"and\\t%1,(%2)\";
+else
+	return \"and\\t%1,%2\";
+
+}")
+
+(define_insn "iorsi3"
+  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+	(ior:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "general_operand" "Dim")))
+         (clobber (match_scratch:QI 3 "=&a"))
+         (clobber (match_scratch:HI 4 "=&b"))])]  
+ ""
+  "#")
+
+(define_split 
+  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+	(ior:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "general_operand" "Dmi")))       
+         (clobber (match_scratch:QI 3 "=&a"))  
+         (clobber (match_scratch:HI 4 "=&b"))])] 
+"reload_completed"
+[(set (match_dup 4) (match_dup 7))
+(parallel[(set (match_dup 5) (ior:HI (match_dup 5) (match_dup 4))) (clobber (reg:QI 0))])      
+ (set (match_dup 4) (match_dup 8))       
+(parallel[(set (match_dup 6) (ior:HI (match_dup 6) (match_dup 4))) (clobber (reg:QI 0))])]
+   
+"operands[4] = gen_rtx_REG (HImode, REGNO (operands[4]));
+  operands[5] = z80_gen_lowpart (HImode, operands[1]);
+   operands[6] = z80_gen_highpart (HImode, operands[1]);
+   operands[7] = z80_gen_lowpart (HImode, operands[2]);
+   operands[8] = z80_gen_highpart (HImode, operands[2]);")  
+
+
+(define_insn "iorhi3"
+  [(parallel[(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (match_operand:HI 1 "register_operand" "%0")
+		(match_operand:HI 2 "register_operand" "r")))  
+        (clobber (match_scratch:QI 3 "=a"))])]
+  ""
+"#")
+
+(define_split 
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (match_operand:HI 1 "register_operand" "%0")
+		(match_operand:HI 2 "register_operand" "r")))   
+        (clobber (match_scratch:QI 3 "=a"))]
+  "reload_completed"
+ [(set (match_dup 3) (match_dup 4))
+ (set (match_dup 3) (ior:QI (match_dup 3) (match_dup 6) ))   
+ (set (match_dup 4) (match_dup 3))
+ (set (match_dup 3) (match_dup 5))
+ (set (match_dup 3) (ior:QI (match_dup 3) (match_dup 7) ))
+ (set (match_dup 5) (match_dup 3))]
+"operands[4] = z80_gen_lowpart (QImode,operands[1] );
+   operands[5] = z80_gen_highpart (QImode, operands[1]);
+   operands[6] = z80_gen_lowpart (QImode,operands[2]);
+   operands[7] = z80_gen_highpart (QImode, operands[2]);") 
+
+(define_insn "iorqi3"
+  [(set (match_operand:QI 0 "register_operand" "=a")
+	(ior:QI (match_operand:QI 1 "register_operand" "%0")
+	     (match_operand:QI 2 "general_operand" "rUi")))]
+  ""
+ "*
+{
+if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int val = INTVAL (operands[2]) & 0x0FF;
+
+      if (val == 0)
+    {
+      cc_status = cc_prev_status;
+      return \"\";
+    }
+	return \"or\\t%0,%1\";
+}
+
+if (GET_CODE (operands[2]) == MEM)
+ 	return \"or\\t%1,(%2)\";
+else
+ 	return \"or\\t%1,%2\";
+}")
+
+(define_insn "xorsi3"
+  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+	(xor:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "general_operand" "Dim")))
+         (clobber (match_scratch:QI 3 "=&a"))
+         (clobber (match_scratch:HI 4 "=&b"))])]  
+ ""
+  "#")
+
+(define_split 
+  [(parallel[(set (match_operand:SI 0 "register_operand" "=D")
+	(xor:SI (match_operand:SI 1 "register_operand" "%0")
+		(match_operand:SI 2 "general_operand" "Dmi")))       
+         (clobber (match_scratch:QI 3 "=&a"))  
+         (clobber (match_scratch:HI 4 "=&b"))])] 
+"reload_completed"
+[(set (match_dup 4) (match_dup 7))
+(parallel[(set (match_dup 5) (xor:HI (match_dup 5) (match_dup 4))) (clobber (reg:QI 0))])      
+ (set (match_dup 4) (match_dup 8))       
+(parallel[(set (match_dup 6) (xor:HI (match_dup 6) (match_dup 4))) (clobber (reg:QI 0))])]
+   
+"operands[4] = gen_rtx_REG (HImode, REGNO (operands[4]));
+  operands[5] = z80_gen_lowpart (HImode, operands[1]);
+   operands[6] = z80_gen_highpart (HImode, operands[1]);
+   operands[7] = z80_gen_lowpart (HImode, operands[2]);
+   operands[8] = z80_gen_highpart (HImode, operands[2]);")  
+
+
+(define_insn "xorhi3"
+  [(parallel[(set (match_operand:HI 0 "register_operand" "=r")
+	(xor:HI (match_operand:HI 1 "register_operand" "%0")
+		(match_operand:HI 2 "register_operand" "r")))  
+        (clobber (match_scratch:QI 3 "=a"))])]
+  ""
+"#")
+
+(define_split 
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(xor:HI (match_operand:HI 1 "register_operand" "%0")
+		(match_operand:HI 2 "register_operand" "r")))   
+        (clobber (match_scratch:QI 3 "=a"))]
+  "reload_completed"
+ [(set (match_dup 3) (match_dup 4))
+ (set (match_dup 3) (xor:QI (match_dup 3) (match_dup 6) ))   
+ (set (match_dup 4) (match_dup 3))
+ (set (match_dup 3) (match_dup 5))
+ (set (match_dup 3) (xor:QI (match_dup 3) (match_dup 7) ))
+ (set (match_dup 5) (match_dup 3))]
+"operands[4] = z80_gen_lowpart (QImode,operands[1] );
+   operands[5] = z80_gen_highpart (QImode, operands[1]);
+   operands[6] = z80_gen_lowpart (QImode,operands[2]);
+   operands[7] = z80_gen_highpart (QImode, operands[2]);") 
+
+(define_insn "xorqi3"
+  [(set (match_operand:QI 0 "register_operand" "=a")
+        (xor:QI (match_operand:QI 1 "register_operand" "%0")
+             (match_operand:QI 2 "general_operand" "rUi")))]
+  ""
+"*
+{
+ if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int val = INTVAL (operands[2]) & 0x0FFFF;
+
+      if (val == 0)
+    {
+      cc_status = cc_prev_status;
+      return \"\";
+    }
+	CC_STATUS_INIT;
+	return \"xor\\t%0,%1\";
+}
+CC_STATUS_INIT;
+if (GET_CODE (operands[2]) == MEM)
+	return \"xor\\t%1,(%2)\";
+else
+   return \"xor\\t%1,%2\";
+}")
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(neg:SI (match_operand:SI 1 "nonimmediate_operand" "0")))   
+       (clobber (match_scratch:HI 2 "=&b"))]
+""
+  "#")
+(define_split
+ [(set (match_operand:SI 0 "nonimmediate_operand" "=r")
+       (neg:SI (match_operand:SI 1 "nonimmediate_operand" "0")))    
+   (clobber (match_scratch:HI 2 "=&b"))]
+"reload_completed"
+[(set (match_dup 2) (match_dup 3))
+(parallel[(set (match_dup 2) (neg:HI (match_dup 2))) (clobber (match_dup 3))])
+(set (match_dup 3) (const_int 0))   
+(set  (match_dup 3) (minus:HI (minus:HI (reg:HI 14) (match_dup 3)) (match_dup 4)))
+ (set (match_dup 4) (match_dup 3))
+(set  (match_dup 3) (match_dup 2))]
+"operands[3]=z80_gen_lowpart(HImode,operands[0]);
+ operands[4]=z80_gen_highpart(HImode,operands[0]);")
+
+
+;;-----------------------
+(define_insn "neghi2"
+  [(set (match_operand:HI 0 "register_operand" "=bd")
+	(neg:HI (match_operand:HI 1 "register_operand" "0")))    
+      (clobber (match_scratch:HI 2 "=&h"))]
+"" 
+"#")
+(define_split
+[(set (match_operand:HI 0 "register_operand" "=r")
+      (neg:HI (match_operand:HI 1 "register_operand" "0")))         
+    (clobber (match_scratch:HI 2 "=&h"))]
+
+"reload_completed" 
+[(set (match_dup 2) (const_int 0))   
+ (set (match_dup 2) (minus:HI (match_dup 2) (match_dup 1)))
+ (set (match_dup 0) (match_dup 2))]
+
+"")
+
+(define_insn "negqi2"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=a")
+	(neg:QI (match_operand:QI 1 "nonimmediate_operand" "0")))]
+  ""
+ "neg")
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(not:SI (match_operand:SI 1 "register_operand" "0")))    
+    (clobber (match_scratch:HI 2 "=&b"))]     
+ ""
+ "#")
+(define_split
+[(set (match_operand:SI 0 "register_operand" "=r")
+       (not:SI (match_operand:SI 1 "register_operand" "0")))   
+     (clobber (match_scratch:HI 2 "=&b"))]
+"reload_completed"
+[(set (match_dup 2) (match_dup 3))
+(parallel[(set (match_dup 2) (not:HI (match_dup 2))) (clobber (match_dup 3))])
+(set (match_dup 3) (const_int -1))   
+(set  (match_dup 3) (minus:HI (minus:HI (reg:HI 14) (match_dup 3)) (match_dup 4)))
+ (set (match_dup 4) (match_dup 3))
+(set (match_dup 3) (match_dup 2))]
+"operands[3]=z80_gen_lowpart(HImode, operands[0]);
+ operands[4]=z80_gen_highpart(HImode, operands[0]);")
+
+;;-----------------------
+(define_insn "one_cmplhi2"
+  [(set (match_operand:HI 0 "register_operand" "=bd")
+	(not:HI (match_operand:HI 1 "register_operand" "0")))
+   (clobber (match_scratch:HI 2 "=&h"))] 
+ ""
+ "#")
+(define_split
+ [(set (match_operand:HI 0 "register_operand" "=bd")
+        (not:HI (match_operand:HI 1 "register_operand" "0")))
+    (clobber (match_scratch:HI 2 "=&h"))]
+"reload_completed"
+[(set (match_dup 2) (const_int -1))
+ (set (match_dup 2) (minus:HI (match_dup 2) (match_dup 1)))
+(set (match_dup 1) (match_dup 2))]
+"")
+
+;;-----------------------
+(define_insn "one_cmplqi2"
+  [(set (match_operand:QI 0 "non_push_operand" "=a")
+	(not:QI (match_operand:QI 1 "general_operand" "0")))]
+ ""
+ "cpl")
+
+
+;; Probably I need to make a library call in side the shift patterns.
+;;So that size of this file will be less. ?? (for SImode).
+
+;;need to make some of the shifts as library calls. (libgcc1.).
+;; So that  the code size won't grow.
+
+
+(define_expand "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(ashift:SI (match_operand:SI 1 "register_operand" "")
+	           (match_operand:HI 2 "general_operand" "")))]
+  ""
+ "")
+
+
+(define_insn "ashlsi3_const1"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(ashift:SI (match_operand:SI 1 "register_operand" "0")
+	           (const_int 1)))]
+  ""
+  "*
+  {
+ operands[3] = z80_gen_lowpart(HImode, operands[0]);
+ operands[4] = z80_gen_highpart(HImode, operands[0]);
+ operands[5] = z80_gen_lowpart(QImode, operands[3]);
+ operands[6] = z80_gen_highpart(QImode, operands[3]);
+ operands[7] = z80_gen_lowpart(QImode, operands[4]);
+ operands[8] = z80_gen_highpart(QImode, operands[4]);
+	output_asm_insn (\"sla\\t%5\", operands);
+	output_asm_insn (\"rl\\t%6\", operands);
+	output_asm_insn (\"rl\\t%7\", operands);
+  return \"rl\\t%8\";
+}")
+
+(define_insn "*ashlsi3_const16"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(ashift:SI (match_operand:SI 1 "register_operand" "0")
+	           (const_int 16)))]
+  ""
+  "*
+  {
+ operands[3] = z80_gen_lowpart(HImode, operands[0]);
+ operands[4] = z80_gen_highpart(HImode, operands[0]);
+
+output_asm_insn (\"ld\\t%4,%3\", operands);
+ return \"ld\\t%3,0\";
+}")
+
+
+(define_insn "*ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(ashift:SI (match_operand:SI 1 "register_operand" "0")
+	           (match_operand:HI 2 "general_operand" "b")))]
+   ""
+   "*
+{
+  rtx label[2];
+
+  
+CC_STATUS_INIT;
+ operands[3] = z80_gen_lowpart (QImode, operands[2]);
+ operands[4] = z80_gen_highpart (QImode, operands[2]);
+output_asm_insn (\"ld\\t%4,%3\", operands);
+  operands[5] = z80_gen_lowpart (HImode, operands[0]);
+  operands[6] = z80_gen_highpart (HImode, operands[0]);
+ operands[7] = z80_gen_lowpart(QImode, operands[5]);
+ operands[8] = z80_gen_highpart(QImode, operands[5]);
+ operands[9] = z80_gen_lowpart(QImode, operands[6]);
+ operands[10] = z80_gen_highpart(QImode, operands[6]);
+	label[0] = gen_label_rtx ();
+	label[1] = gen_label_rtx ();
+
+	output_asm_insn (\"inc\\t%4\",operands);
+	output_asm_insn (\"dec\\t%4\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[0]));
+	output_asm_insn (\"sla\\t%7\", operands);
+	output_asm_insn (\"rl\\t%8\", operands);
+	output_asm_insn (\"rl\\t%9\", operands);
+	output_asm_insn (\"rl\\t%10\", operands);
+	output_asm_insn (\"djnz\\t%l0\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[1]));
+
+   return \"\";
+}")
+
+(define_expand "ashlhi3"
+  [(set (match_operand:HI 0 "register_operand" "")
+	(ashift:HI (match_operand:HI 1 "register_operand" "")
+	           (match_operand:HI 2 "general_operand" "")))]
+   ""
+   "")
+
+(define_insn "*ashlhi3_const1"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(ashift:HI (match_operand:HI 1 "register_operand" "0")
+	           (const_int 1)))]
+  ""
+  "*
+{
+operands[2]= z80_gen_lowpart (QImode, operands[0]);
+operands[3]= z80_gen_highpart (QImode, operands[0]);
+output_asm_insn (\"sla\\t%2\", operands);
+output_asm_insn (\"rl\\t%3\", operands);
+return\"\";
+}")
+/* just check the output when the shift count is 15. */
+
+(define_insn "*ashlhi3_const"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(ashift:HI (match_operand:HI 1 "register_operand" "0")
+	           (match_operand:HI 2 "const_int_operand" "")))]
+  ""
+  "*
+{
+  int	i;
+	
+	operands[3] = z80_gen_lowpart (QImode, operands[0]);
+	operands[4] = z80_gen_highpart (QImode, operands[1]);
+	
+  i = INTVAL (operands[2]);
+  if (i >= 8)
+    {
+      CC_STATUS_INIT;
+      output_asm_insn (\"ld\\t%4,%3\", operands);
+      if (i == 15)
+        {
+	  output_asm_insn (\"rr\\t%4\", operands);
+	  output_asm_insn (\"ld\\t%4,0\", operands);
+	  output_asm_insn (\"rr\\t%4\", operands);
+	}
+      else
+        while (i != 8 )
+          {
+            output_asm_insn (\"sla\\t%4\", operands);
+	    i--;
+	  }
+      return \"ld\\t%3,0\";
+    }
+  for (i = 0; i < INTVAL (operands[2]); i++) 
+    {
+      output_asm_insn (\"sla\\t%3\", operands);
+      output_asm_insn (\"rl\\t%4\", operands);
+    }
+  return \"\";
+}")
+
+(define_insn "*ashlhi3"
+  [(set (match_operand:HI 0 "register_operand" "=hd")
+	(ashift:HI (match_operand:HI 1 "register_operand" "0")
+	           (match_operand:HI 2 "general_operand" "b")))]   
+ 
+""
+  "*
+{
+  rtx label[2];
+operands[3] = z80_gen_lowpart (QImode, operands[1]);
+ operands[4] = z80_gen_highpart (QImode, operands[1]);
+  
+operands[5] = z80_gen_lowpart  (QImode, operands[2]);
+ operands[6] = z80_gen_highpart (QImode, operands[2]);
+	output_asm_insn (\"ld\\t%6,%5\", operands);
+	
+    label[0] = gen_label_rtx ();
+	label[1] = gen_label_rtx ();
+	output_asm_insn (\"inc\\t%6\",operands);
+	output_asm_insn (\"dec\\t%6\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[0]));
+	output_asm_insn (\"sla\\t%3\", operands);
+	output_asm_insn (\"rl\\t%4\", operands);
+	output_asm_insn (\"djnz\\t%l0\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[1]));
+
+	return\"\";
+}")
+
+;;-----------------------
+
+(define_expand "ashlqi3"
+  [(set (match_operand:QI 0 "register_operand" "")
+    (ashift:QI (match_operand:QI 1 "register_operand" "")
+               (match_operand:QI 2 "general_operand" "")))]
+   ""
+"")
+
+(define_insn "*ashlqi3_const1"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbda")
+	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0")
+	           (const_int 1)))]
+  ""
+  "sla\\t%0")
+
+
+(define_insn "*ashlqi3_const"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbda")
+	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0")
+	           (match_operand:QI 2 "const_int_operand" "")))]
+  ""
+  "*
+{
+  int i;
+  i = INTVAL(operands[2]);
+  if (i >= 8)
+    {
+     return \"ld\\t%0,0\";
+   }
+  else if (i == 7)
+    {
+          output_asm_insn (\"rr\\t%0\", operands);
+          output_asm_insn (\"ld\\t%0,0\", operands);
+          return \"rr\\t%0\";
+    }
+  while (--i >= 0)
+    {
+      output_asm_insn (\"sla\\t%0\", operands);
+    }
+  return \"\";
+}")
+/* here there is a problem  if the operands[2] is going to be a symbolic memory 
+variable we can not get that in register b.
+  But any way that case is not being mapped to ashlqi3 ( bramha )
+*/
+
+(define_insn "*ashlqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=hda")
+	(ashift:QI (match_operand:QI 1 "nonimmediate_operand" "0")
+            (match_operand:QI 2 "nonimmediate_operand" "b")))]
+  ""
+  "*
+{
+ rtx label[2];
+ 
+CC_STATUS_INIT;
+
+label[0]  = gen_label_rtx ();
+label[1] = gen_label_rtx ();
+operands[2] = gen_rtx_REG (QImode, HARD_B_REGNUM);
+operands[3] = gen_rtx_REG (QImode, HARD_C_REGNUM);
+output_asm_insn (\"ld\\t%2,%3\", operands);
+output_asm_insn (\"inc\\t%2\", operands);
+output_asm_insn (\"dec\\t%2\", operands);
+output_asm_insn (\"jr\\tz,%l1\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[0]));
+output_asm_insn (\"sla\\t%0\", operands);
+output_asm_insn (\"djnz\\t%l0\", label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[1]));
+
+ return \"\";
+
+}")
+
+(define_expand "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand" "")
+	             (match_operand:HI 2 "general_operand" "")))]
+  
+ ""
+ "")
+
+;;-----------------------
+(define_insn "*ashrsi3_const1"
+  [(set (match_operand:SI 0 "non_push_operand" "=D")
+	(ashiftrt:SI (match_operand:SI 1 "non_push_operand" "0")
+	             (const_int 1)))]
+  ""
+"* 
+{
+ operands[3] = z80_gen_lowpart(HImode, operands[0]);
+ operands[4] = z80_gen_highpart(HImode, operands[0]);
+ operands[5] = z80_gen_lowpart(QImode, operands[3]);
+ operands[6] = z80_gen_highpart(QImode, operands[3]);
+ operands[7] = z80_gen_lowpart(QImode, operands[4]);
+ operands[8] = z80_gen_highpart(QImode, operands[4]);
+	output_asm_insn (\"sra\\t%8\", operands);
+	output_asm_insn (\"rr\\t%7\", operands);
+	output_asm_insn (\"rr\\t%6\", operands);
+  return \"rr\\t%5\";
+
+}")
+
+(define_insn "*ashrsi3"
+[(set (match_operand:SI 0 "register_operand" "=D")
+       (ashiftrt:SI (match_operand:SI 1 "register_operand" "0")
+					(match_operand:HI 2 "general_operand" "b")))]
+""
+"*
+{
+ rtx label[2];
+ operands[3] = z80_gen_lowpart (QImode, operands[2]);
+ operands[4] = z80_gen_highpart (QImode, operands[2]);
+output_asm_insn (\"ld\\t%4,%3\", operands);
+  operands[5] = z80_gen_lowpart (HImode, operands[0]);
+  operands[6] = z80_gen_highpart (HImode, operands[0]);
+ operands[7] = z80_gen_lowpart(QImode, operands[5]);
+ operands[8] = z80_gen_highpart(QImode, operands[5]);
+ operands[9] = z80_gen_lowpart(QImode, operands[6]);
+ operands[10] = z80_gen_highpart(QImode, operands[6]);
+	
+	label[0] = gen_label_rtx ();
+	label[1] = gen_label_rtx ();
+	
+    output_asm_insn (\"inc\\t%4\",operands);
+	output_asm_insn (\"dec\\t%4\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[0]));
+  
+	output_asm_insn (\"sra\\t%10\", operands);
+	output_asm_insn (\"rr\\t%9\", operands);
+	output_asm_insn (\"rr\\t%8\", operands);
+	output_asm_insn (\"rr\\t%7\", operands);
+	output_asm_insn (\"djnz\\t%l0\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[1]));
+
+		return \"\";
+
+
+}")
+
+(define_expand "ashrhi3"
+  [(set (match_operand:HI 0 "register_operand" "")
+	(ashiftrt:HI (match_operand:HI 1 "register_operand" "")
+	             (match_operand:HI 2 "general_operand" "")))]
+   ""
+   "")
+
+
+;;-----------------------
+(define_insn "*ashrhi3_const1"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(ashiftrt:HI (match_operand:HI 1 "register_operand" "0")
+	             (const_int 1)))]
+  ""
+  "*
+{
+  CC_STATUS_INIT;
+operands[2]= z80_gen_lowpart (QImode, operands[0]);
+operands[3]= z80_gen_highpart (QImode, operands[0]);
+output_asm_insn (\"sra\\t%3\", operands);
+output_asm_insn (\"rr\\t%2\", operands);
+return\"\";
+}")
+
+(define_insn "*ashrhi3"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=hb")
+	(ashiftrt:HI (match_operand:HI 1 "nonimmediate_operand" "0")
+     (match_operand:HI 2 "general_operand" "b")))]
+  ""
+  "*
+{
+ rtx label[2];
+
+  CC_STATUS_INIT;
+operands[3] = z80_gen_lowpart (QImode, operands[1]);
+ operands[4] = z80_gen_highpart (QImode, operands[1]);
+  
+operands[5] = z80_gen_lowpart  (QImode, operands[2]);
+ operands[6] = z80_gen_highpart (QImode, operands[2]);
+	output_asm_insn (\"ld\\t%6,%5\", operands);
+	
+    label[0] = gen_label_rtx ();
+	label[1] = gen_label_rtx ();
+ 
+ label[0] = gen_label_rtx ();
+  label[1] = gen_label_rtx ();
+	output_asm_insn (\"inc\\t%6\", operands);
+	output_asm_insn (\"dec\\t%6\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+			     CODE_LABEL_NUMBER (label[0]));
+
+  output_asm_insn (\"sra\\t%4\", operands);
+  output_asm_insn (\"rr\\t%3\", operands);
+  output_asm_insn (\"djnz\\t%l0\", label);
+
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+			     CODE_LABEL_NUMBER (label[1]));
+  return \"\";
+}")
+
+(define_expand "ashrqi3"
+  [(set (match_operand:QI 0 "register_operand" "")
+	(ashiftrt:QI (match_operand:QI 1 "register_operand" "")
+	             (match_operand:QI 2 "general_operand" "")))]
+   ""
+   "")
+
+
+;;-----------------------
+(define_insn "*ashrqi3_const1"
+  [(set (match_operand:QI 0 "register_operand" "=hbda")
+	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
+		     (const_int 1)))]
+  ""
+"sra\\t%0")
+
+(define_insn "*ashrqi3_const"
+  [(set (match_operand:QI 0 "register_operand" "=hbda")
+	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
+	             (match_operand:QI 2 "const_int_operand" "")))]
+  ""
+  "*
+{
+  int i;
+  i = INTVAL (operands[2]);
+  if (i > 8)
+    i = 8;
+  while (--i >= 0)
+    {
+      output_asm_insn (\"sra\\t%0\", operands);
+    }
+  return \"\";
+}")
+
+;; you need register b to keep the count. It will fail to load symbolic
+;; memory in to register b, that case not being mapped to ashrqi, they are
+;; mapped to ashrsi (the values are sign extended and being mapped to ashrhi */
+
+
+(define_insn "*ashrqi3"
+  [(set (match_operand:QI 0 "register_operand" "=hda")
+	(ashiftrt:QI (match_operand:QI 1 "register_operand" "0")
+	    (match_operand:QI 2 "nonimmediate_operand" "b")))]
+  ""
+  "*
+{
+ rtx label[2];
+ 
+CC_STATUS_INIT;
+
+label[0]  = gen_label_rtx ();
+label[1] = gen_label_rtx ();
+operands[2] = gen_rtx_REG (QImode, HARD_B_REGNUM);
+operands[3] = gen_rtx_REG (QImode, HARD_C_REGNUM);
+output_asm_insn (\"ld\\t%2,%3\", operands);
+output_asm_insn (\"inc\\t%2\", operands);
+output_asm_insn (\"dec\\t%2\", operands);
+	output_asm_insn (\"inc\\t%2\", operands);
+	output_asm_insn (\"dec\\t%2\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[0]));
+
+output_asm_insn (\"sra\\t%0\", operands);
+output_asm_insn (\"djnz\\t%l0\", label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[1]));
+
+ return \"\";
+
+}")
+
+(define_expand "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "")
+	             (match_operand:HI 2 "general_operand" "")))] 
+  
+ ""
+"")
+
+;;-----------------------
+(define_insn "*lshrsi3_const1"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+	             (const_int 1)))]
+   
+  ""
+ "*
+{
+operands[3] = z80_gen_lowpart(HImode, operands[0]);
+ operands[4] = z80_gen_highpart(HImode, operands[0]);
+ operands[5] = z80_gen_lowpart(QImode, operands[3]);
+ operands[6] = z80_gen_highpart(QImode, operands[3]);
+ operands[7] = z80_gen_lowpart(QImode, operands[4]);
+ operands[8] = z80_gen_highpart(QImode, operands[4]);
+	output_asm_insn (\"srl\\t%8\", operands);
+	output_asm_insn (\"rr\\t%7\", operands);
+	output_asm_insn (\"rr\\t%6\", operands);
+  return \"rr\\t%5\";
+
+}")
+
+(define_insn "*lshrsi3_const16"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+	             (const_int 16)))]
+   
+  ""
+ "*
+{
+operands[3] = z80_gen_lowpart(HImode, operands[0]);
+ operands[4] = z80_gen_highpart(HImode, operands[0]);
+output_asm_insn (\"ld\\t%3,%4\", operands);
+ return \"ld\\t%4,0\";
+}")
+
+
+(define_insn "*lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=D")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+                 (match_operand:HI 2 "general_operand" "b")))]  
+  ""
+"*
+{
+ rtx label[2];
+
+CC_STATUS_INIT;
+ operands[3] = z80_gen_lowpart (QImode, operands[2]);
+ operands[4] = z80_gen_highpart (QImode, operands[2]);
+output_asm_insn (\"ld\\t%4,%3\", operands);
+  operands[5] = z80_gen_lowpart (HImode, operands[0]);
+  operands[6] = z80_gen_highpart (HImode, operands[0]);
+ operands[7] = z80_gen_lowpart(QImode, operands[5]);
+ operands[8] = z80_gen_highpart(QImode, operands[5]);
+ operands[9] = z80_gen_lowpart(QImode, operands[6]);
+ operands[10] = z80_gen_highpart(QImode, operands[6]);
+	label[0] = gen_label_rtx ();
+	label[1] = gen_label_rtx ();
+
+	output_asm_insn (\"inc\\t%4\",operands);
+	output_asm_insn (\"dec\\t%4\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[0]));
+	output_asm_insn (\"srl\\t%10\", operands);
+	output_asm_insn (\"rr\\t%9\", operands);
+	output_asm_insn (\"rr\\t%8\", operands);
+	output_asm_insn (\"rr\\t%7\", operands);
+	output_asm_insn (\"djnz\\t%l0\",label);
+ ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (label[1]));
+
+   return \"\";
+}")
+
+;;-----------------------
+(define_expand "lshrhi3"
+  [(set (match_operand:HI 0 "register_operand" "")
+	(lshiftrt:HI (match_operand:HI 1 "register_operand" "")
+	             (match_operand:HI 2 "general_operand" "")))]
+   ""
+ "")
+
+
+
+;;-----------------------
+(define_insn "lshrhi3_const1"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
+		     (const_int 1)))]
+  ""
+  "*
+{
+  CC_STATUS_INIT;
+operands[2]= z80_gen_lowpart (QImode, operands[0]);
+operands[3]= z80_gen_highpart (QImode, operands[0]);
+output_asm_insn (\"srl\\t%3\", operands);
+output_asm_insn (\"rr\\t%2\", operands);
+return\"\";
+}")
+
+(define_insn ""
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
+		     (const_int 8)))]
+  ""
+  "*
+{
+  CC_STATUS_INIT;
+operands[2]=gen_rtx_REG (QImode, REGNO(operands[0]));
+operands[3]=gen_rtx_REG (QImode, REGNO(operands[0])+1);
+output_asm_insn (\"ld\\t%2,%3\", operands);
+output_asm_insn (\"ld\\t%3,0\", operands);
+return\"\";
+}")
+
+;;-----------------------
+
+(define_insn "*lshrhi3"
+  [(set (match_operand:HI 0 "register_operand" "=hd")
+	(lshiftrt:HI (match_operand:HI 1 "register_operand" "0")
+		(match_operand:HI 2 "general_operand" "b")))]
+  ""
+  "*
+{
+ rtx label[2];
+  CC_STATUS_INIT;
+operands[3] = z80_gen_lowpart (QImode, operands[1]);
+ operands[4] = z80_gen_highpart (QImode, operands[1]);
+  
+operands[5] = z80_gen_lowpart  (QImode, operands[2]);
+ operands[6] = z80_gen_highpart (QImode, operands[2]);
+	output_asm_insn (\"ld\\t%6,%5\", operands);
+	
+    label[0] = gen_label_rtx ();
+	label[1] = gen_label_rtx ();
+ 
+	output_asm_insn (\"inc\\t%6\", operands);
+	output_asm_insn (\"dec\\t%6\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+			     CODE_LABEL_NUMBER (label[0]));
+
+  output_asm_insn (\"srl\\t%4\", operands);
+  output_asm_insn (\"rr\\t%3\", operands);
+  output_asm_insn (\"djnz\\t%l0\", label);
+
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+			     CODE_LABEL_NUMBER (label[1]));
+  return \"\";
+}")
+
+(define_expand "lshrqi3"
+  [(set (match_operand:QI 0 "register_operand" "")
+	(lshiftrt:QI (match_operand:QI 1 "register_operand" "")
+	             (match_operand:QI 2 "general_operand" "")))]
+   ""
+  "")
+
+
+;;-----------------------
+(define_insn "*lshrqi3_const1"
+  [(set (match_operand:QI 0 "register_operand" "=ahd")
+	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
+		     (const_int 1)))]
+ ""
+  "srl\\t%0")
+
+
+;;-----------------------
+
+(define_insn "*lshrqi3"
+  [(set (match_operand:QI 0 "register_operand" "=ahd")
+	(lshiftrt:QI (match_operand:QI 1 "register_operand" "0")
+     (match_operand:QI 2 "nonimmediate_operand" "b")))]
+  ""
+  "*
+{
+ rtx label[2];
+
+  CC_STATUS_INIT;
+  label[0] = gen_label_rtx ();
+  label[1] = gen_label_rtx ();
+operands[2] = gen_rtx_REG (QImode, HARD_B_REGNUM);
+operands[3] = gen_rtx_REG (QImode, HARD_C_REGNUM);
+output_asm_insn (\"ld\\t%2,%3\", operands);
+	output_asm_insn (\"inc\\t%2\",operands);
+	output_asm_insn (\"dec\\t%2\", operands);
+	output_asm_insn (\"jr\\tz,%l1\",label);
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+			     CODE_LABEL_NUMBER (label[0]));
+
+  output_asm_insn (\"srl\\t%1\", operands);
+  output_asm_insn (\"djnz\\t%l0\", label);
+
+  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+			     CODE_LABEL_NUMBER (label[1]));
+  return \"\";
+
+}")
+
+;; These rotate patterns (?? when are they get invoked)
+;; In some of the splits for shifts and extendm1m2 patterns I am explicitly
+;; invoking rotate with carry patterns for qimode.
+;; Rest of them are not being used.
+;; 
+
+(define_insn "*rotlqi3_with_carry"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbdaU")
+	(rotate:QI (match_operand:QI 1 "nonimmediate_operand" "0")
+		   (reg:QI 14)))]
+  ""
+  "*
+{
+if (GET_CODE (operands[0]) == MEM)
+      return \"rl\\t(%0)\";                   
+else
+return \"rl\\t%0\";
+
+}")
+
+/* not really needed */
+
+;;-----------------------
+(define_insn "*rotlhi3_with_carry"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(rotate:HI (match_operand:HI 1 "register_operand" "0")
+		   (reg:HI 14)))]
+  ""
+  "*
+{
+operands[3]=z80_gen_lowpart(QImode, operands[0]);
+operands[4]=z80_gen_highpart(QImode, operands[0]);
+ output_asm_insn (\"rl\\t%3\", operands);
+output_asm_insn (\"rl\\t%4\", operands);
+return \"\";
+}")
+
+
+
+
+;;-----------------------
+
+
+(define_insn "*rotrqi3_with_carry"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=hbdaU")
+	(rotatert:QI (match_operand:QI 1 "nonimmediate_operand" "0")
+		     (reg:QI 14)))]
+  ""
+  "*
+{
+  CC_STATUS_INIT;
+if (GET_CODE (operands[0]) == MEM)
+     return \"rr\\t(%0)\";
+else
+return\"rr\\t%0\";
+
+}")
+
+(define_insn "*rotrhi3_with_carry"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(rotatert:HI (match_operand:HI 1 "register_operand" "0")
+		     (reg:HI 14)))]
+  ""
+  "#")
+
+(define_split
+ [(set (match_operand:HI 0 "register_operand" "=hbd")
+       (rotatert:HI (match_operand:HI 1 "register_operand" "0")
+                     (reg:HI 14)))]
+"reload_completed"
+[(set (match_dup 2) (rotatert:QI (match_dup 2) (reg:QI 8)))
+  (set (match_dup 3) (rotatert:QI (match_dup 3) (reg:QI 8)))]
+
+"operands[2]=z80_gen_lowpart(QImode, operands[0]);
+ operands[3]=z80_gen_highpart(QImode, operands[0]);
+")
+
+;; It is not clear when these rtl patterns are mapped. So, just left it
+;like that. Need to implement them.
+
+
+(define_insn "rotlqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=ahbdU")
+	(rotate:QI (match_operand:QI 1 "nonimmediate_operand" "0")
+		   (match_operand:QI 2 "const_int_operand" "i")))]
+  ""
+  "*
+{
+ // z80_gen_rotate (ROTATE, insn, operands);
+  return \"rlc\\t%0\";
+}")
+
+
+;;-----------------------
+(define_insn "rotlhi3"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(rotate:HI (match_operand:HI 1 "register_operand" "0")
+		   (match_operand:HI 2 "const_int_operand" "i")))]
+  ""
+  "*
+{
+// z80_gen_rotate (ROTATE, insn, operands);
+  return \"rlc\\t%0\";
+}")
+
+
+;;-----------------------
+(define_insn "rotrqi3"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=ahbdU")
+	(rotatert:QI (match_operand:QI 1 "nonimmediate_operand" "0")
+		     (match_operand:QI 2 "const_int_operand" "i")))]
+  ""
+  "*
+{
+ // z80_gen_rotate (ROTATERT, insn, operands);
+  return \"rra\";
+}")
+
+
+;;-----------------------
+(define_insn "rotrhi3"
+  [(set (match_operand:HI 0 "register_operand" "=hbd")
+	(rotatert:HI (match_operand:HI 1 "register_operand" "0")
+		     (match_operand:HI 2 "const_int_operand" "i")))]
+  ""
+  "*
+{
+ // z80_gen_rotate (ROTATERT, insn, operands);
+  return \"rrc\\t%0\";
+}")
+
+;;--------------------------------------------------------------------
+
+
+
+;;- nop instruction
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop")
+
+;; Unconditional and other jump instructions
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "jp\\t%l0")
+
+(define_expand "tablejump"
+  [(parallel [(set (pc) (match_operand 0 "" ""))
+          (use (label_ref (match_operand 1 "" "")))])]
+  ""
+  "")
+
+(define_insn "*jump_indirect"
+   [(parallel [
+    (set (pc) (match_operand:HI 0 "register_operand" "hxy"))
+    (use (label_ref (match_operand 1 "" "")))])]
+   ""
+  "jp\\t(%0)")
+
+;; indirect jump - let's be conservative!
+;; allow only register_operand, even though we could also 
+;; allow labels etc.
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:HI 0 "register_operand" "=h!xy"))]
+  ""
+  "jp\\t(%0)")
+
+;;- jump to subroutine
+
+;;when making a call through a function pointer you need to be careful. you put
+;; the address in a register and then call happens. We do not have call (iy),so
+;; we simulate it to jp (iy). just check it.
+ 
+
+(define_insn "call"
+  [(call (match_operand:QI 0 "general_operand" "mi")
+     (match_operand:SI 1 "general_operand" "g"))]
+  ""
+  "*
+  {
+		if (GET_CODE( XEXP (operands[0],0)) == REG)
+		{
+        	operands[2] = gen_label_rtx();
+        	operands[3] = gen_label_rtx ();
+        	output_asm_insn (\"call\\t%l2\", operands);
+        	output_asm_insn (\"jp\\t%l3\", operands);
+ 		ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (operands[2]));
+        output_asm_insn (\"jp\\t(%0)\", operands);
+ 		ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (operands[3]));
+            return \"\";
+    	}
+		return \"call\\t(%0)\";
+	}")
+
+
+;;- jump to subroutine
+(define_insn "call_value"
+  [(set (match_operand 0 "" "=g")
+    (call (match_operand:QI 1 "general_operand" "mi")
+          (match_operand:SI 2 "general_operand" "g")))]
+  ""
+  "*
+  {
+
+	if (GET_CODE (XEXP (operands[1],0)) == REG)
+	{
+        operands[3] = gen_label_rtx();
+        operands[4] = gen_label_rtx ();
+        output_asm_insn (\"call\\t%l3\", operands);
+        output_asm_insn (\"jp\\t%l4\", operands);
+ 	ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (operands[3]));
+        output_asm_insn (\"jp\\t(%1)\", operands);
+ 	ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",
+                                 CODE_LABEL_NUMBER (operands[4]));
+            return \"\";
+	}
+	return \"call\\t(%1)\";
+  }")
+
+
+(define_expand "untyped_call"
+  [(parallel [(call (match_operand 0 "" "")
+		    (const_int 0))
+	      (match_operand 1 "" "")
+	      (match_operand 2 "" "")])]
+  ""
+  "
+{
+  int i;
+
+  emit_call_insn (gen_call (operands[0], const0_rtx));
+
+  for (i = 0; i < XVECLEN (operands[2], 0); i++)
+    {
+      rtx set = XVECEXP (operands[2], 0, i);
+      emit_move_insn (SET_DEST (set), SET_SRC (set));
+    }
+
+  /* The optimizer does not know that the call sets the function value
+     registers we stored in the result block.  We avoid problems by
+     claiming that all hard registers are used and clobbered at this
+     point.  */
+  emit_insn (gen_blockage ());
+
+  DONE;
+}")
+
+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and
+;; all of memory.  This blocks insns from being moved across this point.
+
+(define_insn "blockage"
+  [(unspec_volatile [(const_int 0)] 0)]
+  ""
+  "")
+
+
+;;--------------------------------------------------------------------
+;;- Prologue and epilogue.
+;;--------------------------------------------------------------------
+(define_expand "prologue"
+  [(const_int 0)]
+  ""
+  "
+{
+  expand_prologue (); 
+  DONE;
+}")
+
+(define_expand "epilogue"
+  [(const_int 0)]
+  ""
+  "
+{
+  expand_epilogue (); 
+  DONE;
+}")
+
+
+
+(define_expand "return"
+  [(return)]
+  "reload_completed"
+  "
+{
+  int ret_size = 0;
+
+  if (current_function_return_rtx)
+    ret_size = GET_MODE_SIZE (GET_MODE (current_function_return_rtx));
+}
+")
+
+
+
+(define_insn "return_void"
+  [(return)]
+  "reload_completed"
+  "*
+{
+  rtx next = next_active_insn (insn);
+
+  if (next
+      && GET_CODE (next) == JUMP_INSN
+      && GET_CODE (PATTERN (next)) == RETURN)
+    return \"\";
+  if (current_function_interrupt || current_function_trap)
+    return \"retn\";
+  return \"ret\";
+}")
diff -Naur gcc-2.95.2/gcc/configure gcc-2.95.2-z80/gcc/configure
--- gcc-2.95.2/gcc/configure	Wed Oct 13 13:28:02 1999
+++ gcc-2.95.2-z80/gcc/configure	Fri Jun  8 11:23:16 2001
@@ -4971,6 +4971,14 @@
 			use_collect2=yes
 		fi
 		;;
+	z80-zilog-*)
+        tm_file="z80/z80.h"
+        xm_file="z80/xm-z80.h"
+        out_file="z80/z80.c"
+    #   tmake_file="z80/t-z80-gas"
+    #   extra_parts="crt1.o"
+        ;;
+	
 	mn10200-*-*)
 		cpu_type=mn10200
 		tm_file="mn10200/mn10200.h"
@@ -5415,7 +5423,7 @@
                 xmake_file=sparc/x-sysv4
                 extra_parts="crt1.o crti.o crtn.o gmon.o crtbegin.o crtend.o"
                 case $machine in
-                *-*-solaris2.[0-4])
+                *-*-solaris2.0-4)
                         float_format=i128
                 ;;
                 *)
@@ -6049,7 +6057,7 @@
 
 
         echo $ac_n "checking for strerror in -lcposix""... $ac_c" 1>&6
-echo "configure:6044: checking for strerror in -lcposix" >&5
+echo "configure:6061: checking for strerror in -lcposix" >&5
 ac_lib_var=`echo cposix'_'strerror | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -6057,7 +6065,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lcposix  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 6052 "configure"
+#line 6069 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -6068,7 +6076,7 @@
 strerror()
 ; return 0; }
 EOF
-if { (eval echo configure:6063: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6080: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -6091,12 +6099,12 @@
   
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:6086: checking for working const" >&5
+echo "configure:6103: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6091 "configure"
+#line 6108 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -6145,7 +6153,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6140: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6157: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -6166,21 +6174,21 @@
 fi
 
 echo $ac_n "checking for inline""... $ac_c" 1>&6
-echo "configure:6161: checking for inline" >&5
+echo "configure:6178: checking for inline" >&5
 if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat > conftest.$ac_ext <<EOF
-#line 6168 "configure"
+#line 6185 "configure"
 #include "confdefs.h"
 
 int main() {
 } $ac_kw foo() {
 ; return 0; }
 EOF
-if { (eval echo configure:6175: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:6192: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_inline=$ac_kw; break
 else
@@ -6206,12 +6214,12 @@
 esac
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:6201: checking for off_t" >&5
+echo "configure:6218: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6206 "configure"
+#line 6223 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6239,12 +6247,12 @@
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:6234: checking for size_t" >&5
+echo "configure:6251: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6239 "configure"
+#line 6256 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -6274,19 +6282,19 @@
 # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:6269: checking for working alloca.h" >&5
+echo "configure:6286: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6274 "configure"
+#line 6291 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:6281: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6298: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -6307,12 +6315,12 @@
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:6302: checking for alloca" >&5
+echo "configure:6319: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6307 "configure"
+#line 6324 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -6340,7 +6348,7 @@
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:6335: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6352: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -6372,12 +6380,12 @@
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:6367: checking whether alloca needs Cray hooks" >&5
+echo "configure:6384: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6372 "configure"
+#line 6389 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -6402,12 +6410,12 @@
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:6397: checking for $ac_func" >&5
+echo "configure:6414: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6402 "configure"
+#line 6419 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -6430,7 +6438,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6425: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6442: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -6457,7 +6465,7 @@
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:6452: checking stack direction for C alloca" >&5
+echo "configure:6469: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6465,7 +6473,7 @@
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 6460 "configure"
+#line 6477 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -6484,7 +6492,7 @@
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:6479: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6496: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -6509,17 +6517,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:6504: checking for $ac_hdr" >&5
+echo "configure:6521: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6509 "configure"
+#line 6526 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:6514: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:6531: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -6548,12 +6556,12 @@
 for ac_func in getpagesize
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:6543: checking for $ac_func" >&5
+echo "configure:6560: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6548 "configure"
+#line 6565 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -6576,7 +6584,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6571: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6588: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -6601,7 +6609,7 @@
 done
 
 echo $ac_n "checking for working mmap""... $ac_c" 1>&6
-echo "configure:6596: checking for working mmap" >&5
+echo "configure:6613: checking for working mmap" >&5
 if eval "test \"`echo '$''{'ac_cv_func_mmap_fixed_mapped'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -6609,7 +6617,7 @@
   ac_cv_func_mmap_fixed_mapped=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 6604 "configure"
+#line 6621 "configure"
 #include "confdefs.h"
 
 /* Thanks to Mike Haertel and Jim Avera for this test.
@@ -6749,7 +6757,7 @@
 }
 
 EOF
-if { (eval echo configure:6744: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:6761: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_mmap_fixed_mapped=yes
 else
@@ -6777,17 +6785,17 @@
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:6772: checking for $ac_hdr" >&5
+echo "configure:6789: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6777 "configure"
+#line 6794 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:6782: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:6799: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -6817,12 +6825,12 @@
 strdup __argz_count __argz_stringify __argz_next
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:6812: checking for $ac_func" >&5
+echo "configure:6829: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6817 "configure"
+#line 6834 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -6845,7 +6853,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6840: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6857: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -6874,12 +6882,12 @@
      for ac_func in stpcpy
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:6869: checking for $ac_func" >&5
+echo "configure:6886: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6874 "configure"
+#line 6891 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -6902,7 +6910,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:6897: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6914: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -6936,19 +6944,19 @@
 
    if test $ac_cv_header_locale_h = yes; then
     echo $ac_n "checking for LC_MESSAGES""... $ac_c" 1>&6
-echo "configure:6931: checking for LC_MESSAGES" >&5
+echo "configure:6948: checking for LC_MESSAGES" >&5
 if eval "test \"`echo '$''{'am_cv_val_LC_MESSAGES'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 6936 "configure"
+#line 6953 "configure"
 #include "confdefs.h"
 #include <locale.h>
 int main() {
 return LC_MESSAGES
 ; return 0; }
 EOF
-if { (eval echo configure:6943: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:6960: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   am_cv_val_LC_MESSAGES=yes
 else
@@ -6969,7 +6977,7 @@
     fi
   fi
    echo $ac_n "checking whether NLS is requested""... $ac_c" 1>&6
-echo "configure:6964: checking whether NLS is requested" >&5
+echo "configure:6981: checking whether NLS is requested" >&5
         # Check whether --enable-nls or --disable-nls was given.
 if test "${enable_nls+set}" = set; then
   enableval="$enable_nls"
@@ -6989,7 +6997,7 @@
 EOF
 
       echo $ac_n "checking whether included gettext is requested""... $ac_c" 1>&6
-echo "configure:6984: checking whether included gettext is requested" >&5
+echo "configure:7001: checking whether included gettext is requested" >&5
       # Check whether --with-included-gettext or --without-included-gettext was given.
 if test "${with_included_gettext+set}" = set; then
   withval="$with_included_gettext"
@@ -7008,17 +7016,17 @@
 
 	ac_safe=`echo "libintl.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for libintl.h""... $ac_c" 1>&6
-echo "configure:7003: checking for libintl.h" >&5
+echo "configure:7020: checking for libintl.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7008 "configure"
+#line 7025 "configure"
 #include "confdefs.h"
 #include <libintl.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:7013: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:7030: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -7035,19 +7043,19 @@
 if eval "test \"`echo '$ac_cv_header_'$ac_safe`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for gettext in libc""... $ac_c" 1>&6
-echo "configure:7030: checking for gettext in libc" >&5
+echo "configure:7047: checking for gettext in libc" >&5
 if eval "test \"`echo '$''{'gt_cv_func_gettext_libc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7035 "configure"
+#line 7052 "configure"
 #include "confdefs.h"
 #include <libintl.h>
 int main() {
 return (int) gettext ("")
 ; return 0; }
 EOF
-if { (eval echo configure:7042: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7059: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   gt_cv_func_gettext_libc=yes
 else
@@ -7063,7 +7071,7 @@
 
 	   if test "$gt_cv_func_gettext_libc" != "yes"; then
 	     echo $ac_n "checking for bindtextdomain in -lintl""... $ac_c" 1>&6
-echo "configure:7058: checking for bindtextdomain in -lintl" >&5
+echo "configure:7075: checking for bindtextdomain in -lintl" >&5
 ac_lib_var=`echo intl'_'bindtextdomain | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7071,7 +7079,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7066 "configure"
+#line 7083 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7082,7 +7090,7 @@
 bindtextdomain()
 ; return 0; }
 EOF
-if { (eval echo configure:7077: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7094: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7098,12 +7106,12 @@
 if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for gettext in libintl""... $ac_c" 1>&6
-echo "configure:7093: checking for gettext in libintl" >&5
+echo "configure:7110: checking for gettext in libintl" >&5
 if eval "test \"`echo '$''{'gt_cv_func_gettext_libintl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for gettext in -lintl""... $ac_c" 1>&6
-echo "configure:7098: checking for gettext in -lintl" >&5
+echo "configure:7115: checking for gettext in -lintl" >&5
 ac_lib_var=`echo intl'_'gettext | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7111,7 +7119,7 @@
   ac_save_LIBS="$LIBS"
 LIBS="-lintl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7106 "configure"
+#line 7123 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -7122,7 +7130,7 @@
 gettext()
 ; return 0; }
 EOF
-if { (eval echo configure:7117: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7134: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7161,7 +7169,7 @@
 	      # Extract the first word of "msgfmt", so it can be a program name with args.
 set dummy msgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7156: checking for $ac_word" >&5
+echo "configure:7173: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7195,12 +7203,12 @@
 		for ac_func in dcgettext
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:7190: checking for $ac_func" >&5
+echo "configure:7207: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7195 "configure"
+#line 7212 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -7223,7 +7231,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7218: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7235: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -7250,7 +7258,7 @@
 		# Extract the first word of "gmsgfmt", so it can be a program name with args.
 set dummy gmsgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7245: checking for $ac_word" >&5
+echo "configure:7262: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7286,7 +7294,7 @@
 		# Extract the first word of "xgettext", so it can be a program name with args.
 set dummy xgettext; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7281: checking for $ac_word" >&5
+echo "configure:7298: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7318,7 +7326,7 @@
 fi
 
 		cat > conftest.$ac_ext <<EOF
-#line 7313 "configure"
+#line 7330 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -7326,7 +7334,7 @@
 			       return _nl_msg_cat_cntr
 ; return 0; }
 EOF
-if { (eval echo configure:7321: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7338: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   CATOBJEXT=.gmo
 		   DATADIRNAME=share
@@ -7349,7 +7357,7 @@
 
         if test "$CATOBJEXT" = "NONE"; then
 	  echo $ac_n "checking whether catgets can be used""... $ac_c" 1>&6
-echo "configure:7344: checking whether catgets can be used" >&5
+echo "configure:7361: checking whether catgets can be used" >&5
 	  # Check whether --with-catgets or --without-catgets was given.
 if test "${with_catgets+set}" = set; then
   withval="$with_catgets"
@@ -7362,7 +7370,7 @@
 
 	  if test "$nls_cv_use_catgets" = "yes"; then
 	    	    echo $ac_n "checking for main in -li""... $ac_c" 1>&6
-echo "configure:7357: checking for main in -li" >&5
+echo "configure:7374: checking for main in -li" >&5
 ac_lib_var=`echo i'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -7370,14 +7378,14 @@
   ac_save_LIBS="$LIBS"
 LIBS="-li  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 7365 "configure"
+#line 7382 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:7372: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7389: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -7405,12 +7413,12 @@
 fi
 
 	    echo $ac_n "checking for catgets""... $ac_c" 1>&6
-echo "configure:7400: checking for catgets" >&5
+echo "configure:7417: checking for catgets" >&5
 if eval "test \"`echo '$''{'ac_cv_func_catgets'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7405 "configure"
+#line 7422 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char catgets(); below.  */
@@ -7433,7 +7441,7 @@
 
 ; return 0; }
 EOF
-if { (eval echo configure:7428: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:7445: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_catgets=yes"
 else
@@ -7455,7 +7463,7 @@
 	       # Extract the first word of "gencat", so it can be a program name with args.
 set dummy gencat; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7450: checking for $ac_word" >&5
+echo "configure:7467: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GENCAT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7491,7 +7499,7 @@
 		 # Extract the first word of "gmsgfmt", so it can be a program name with args.
 set dummy gmsgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7486: checking for $ac_word" >&5
+echo "configure:7503: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7528,7 +7536,7 @@
 		   # Extract the first word of "msgfmt", so it can be a program name with args.
 set dummy msgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7523: checking for $ac_word" >&5
+echo "configure:7540: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7563,7 +7571,7 @@
 		 # Extract the first word of "xgettext", so it can be a program name with args.
 set dummy xgettext; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7558: checking for $ac_word" >&5
+echo "configure:7575: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7621,7 +7629,7 @@
         # Extract the first word of "msgfmt", so it can be a program name with args.
 set dummy msgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7616: checking for $ac_word" >&5
+echo "configure:7633: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7655,7 +7663,7 @@
         # Extract the first word of "gmsgfmt", so it can be a program name with args.
 set dummy gmsgfmt; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7650: checking for $ac_word" >&5
+echo "configure:7667: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_GMSGFMT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7691,7 +7699,7 @@
         # Extract the first word of "xgettext", so it can be a program name with args.
 set dummy xgettext; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:7686: checking for $ac_word" >&5
+echo "configure:7703: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_XGETTEXT'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -7784,7 +7792,7 @@
        LINGUAS=
      else
        echo $ac_n "checking for catalogs to be installed""... $ac_c" 1>&6
-echo "configure:7779: checking for catalogs to be installed" >&5
+echo "configure:7796: checking for catalogs to be installed" >&5
        NEW_LINGUAS=
        for lang in ${LINGUAS=$ALL_LINGUAS}; do
          case "$ALL_LINGUAS" in
@@ -7812,17 +7820,17 @@
    if test "$CATOBJEXT" = ".cat"; then
      ac_safe=`echo "linux/version.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for linux/version.h""... $ac_c" 1>&6
-echo "configure:7807: checking for linux/version.h" >&5
+echo "configure:7824: checking for linux/version.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 7812 "configure"
+#line 7829 "configure"
 #include "confdefs.h"
 #include <linux/version.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:7817: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:7834: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -8056,7 +8064,7 @@
 
 # Figure out what assembler alignment features are present.
 echo $ac_n "checking assembler alignment features""... $ac_c" 1>&6
-echo "configure:8051: checking assembler alignment features" >&5
+echo "configure:8068: checking assembler alignment features" >&5
 gcc_cv_as=
 gcc_cv_as_alignment_features=
 gcc_cv_as_gas_srcdir=`echo $srcdir | sed -e 's,/gcc$,,'`/gas
@@ -8177,7 +8185,7 @@
 echo "$ac_t""$gcc_cv_as_alignment_features" 1>&6
 
 echo $ac_n "checking assembler subsection support""... $ac_c" 1>&6
-echo "configure:8172: checking assembler subsection support" >&5
+echo "configure:8189: checking assembler subsection support" >&5
 gcc_cv_as_subsections=
 if test x$gcc_cv_as != x; then
 	# Check if we have .subsection
@@ -8217,7 +8225,7 @@
 echo "$ac_t""$gcc_cv_as_subsections" 1>&6
 
 echo $ac_n "checking assembler instructions""... $ac_c" 1>&6
-echo "configure:8212: checking assembler instructions" >&5
+echo "configure:8229: checking assembler instructions" >&5
 gcc_cv_as_instructions=
 if test x$gcc_cv_as != x; then
 	set "filds fists" "filds mem; fists mem"
diff -Naur gcc-2.95.2/gcc/configure.in gcc-2.95.2-z80/gcc/configure.in
--- gcc-2.95.2/gcc/configure.in	Wed Oct 13 13:28:02 1999
+++ gcc-2.95.2-z80/gcc/configure.in	Fri Jun  8 11:23:36 2001
@@ -2656,6 +2656,14 @@
 			use_collect2=yes
 		fi
 		;;
+	z80-zilog-*)
+        tm_file="z80/z80.h"
+        xm_file="z80/xm-z80.h"
+        out_file="z80/z80.c"
+    #   tmake_file="z80/t-z80-gas"
+    #   extra_parts="crt1.o"
+        ;;
+	
 	mn10200-*-*)
 		cpu_type=mn10200
 		tm_file="mn10200/mn10200.h"
